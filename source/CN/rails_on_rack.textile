h2. Rails on Rack

本指南涵盖 Rails 与 Rack 及其他 Rack 组件的集成。参考本指南，你将能够：This guide covers Rails integration with Rack and interfacing with other Rack components. By referring to this guide, you will be able to:

* 创建 Rails Metal 应用Create Rails Metal applications
* 在你的 Rails 应用中使用 Rack 中间件Use Rack Middlewares in your Rails applications
* 理解 Action Pack 的内部中间件堆栈Understand Action Pack's internal Middleware stack
* 定义定制的中间件堆栈Define a custom Middleware stack

endprologue.

WARNING: 本指南假定 Rack 协议及 Rack 概念例如中间件、url 映射和 +Rack::Builder+ 。This guide assumes a working knowledge of Rack protocol and Rack concepts such as middlewares, url maps and +Rack::Builder+.

h3. Rack 简介Introduction to Rack

bq. Rack 为开发 Ruby web 应用提供了一个最小的模块化和适应性接口。通过对 HTTP 请求与响应 的尽可能最简单的方式包装，它统一和提炼 Web 服务器 ，Web 框架，和之间的软件（所谓的中间件）的 API 为一个方法调用。Rack provides a minimal, modular and adaptable interface for developing web applications in Ruby. By wrapping HTTP requests and responses in the simplest way possible, it unifies and distills the API for web servers, web frameworks, and software in between (the so-called middleware) into a single method call.

- "Rack API 文档":http://rack.rubyforge.org/doc/

解释 Rack 并不在本指南的范围内。以防你不熟悉 Rack 的基础，你应该参考下面的"资源":#resources 一节。Explaining Rack is not really in the scope of this guide. In case you are not familiar with Rack's basics, you should check out the "Resources":#resources section below.

h3. Rails on Rack

h4. Rails 应用的 Rack 对象Rails Application's Rack Object

<tt>ActionController::Dispatcher.new</tt> 是一个 Rails 应用的主要 Rack 应用对象。任何 Rack 兼容的 Web 服务器应使用 +ActionController::Dispatcher.new+ 对象作为 Rails 应用。<tt>ActionController::Dispatcher.new</tt> is the primary Rack application object of a Rails application. Any Rack compliant web server should be using +ActionController::Dispatcher.new+ object to serve a Rails application.

h4. +rails server+

<tt>rails server</tt> 做了创建一个 +Rack::Builder+ 对象和启动 web 服务器的基本工作。这是 Rails 的相当于 Rack 的 +rackup+ 脚本。<tt>rails server</tt> does the basic job of creating a +Rack::Builder+ object and starting the webserver. This is Rails' equivalent of Rack's +rackup+ script.

下面是如何使用 +rails server+ 创建一个  +Rack::Builder+ 实例Here's how +rails server+ creates an instance of +Rack::Builder+

<ruby>
app = Rack::Builder.new {
  use Rails::Rack::LogTailer unless options[:detach]
  use Rails::Rack::Debugger if options[:debugger]
  use ActionDispatch::Static
  run ActionController::Dispatcher.new
}.to_app
</ruby>

以上使用中间件的代码中主要在开发环境中有用。下表说明它们的用法：Middlewares used in the code above are primarily useful only in the development environment. The following table explains their usage:

|_.中间件Middleware|_.用途Purpose|
|+Rails::Rack::LogTailer+|追加日志文件输出到控制台Appends log file output to console|
|+ActionDispatch::Static+|提供 +Rails.root/public+ 目录内的静态文件Serves static files inside +Rails.root/public+ directory|
|+Rails::Rack::Debugger+|启动调试器Starts Debugger|

h4. +rackup+

使用 +rackup+ 而不是 Rails 的 +rails server+ ，你可以把下面的 +config.ru+ 放在 Rails 应用的根目录内：To use +rackup+ instead of Rails' +rails server+, you can put the following inside +config.ru+ of your Rails application's root directory:

<ruby>
# Rails.root/config.ru
require "config/environment"

use Rails::Rack::LogTailer
use ActionDispatch::Static
run ActionController::Dispatcher.new
</ruby>

并启动服务器：And start the server:

<shell>
$ rackup config.ru
</shell>

要找出更多其他 +rackup+ 选项：To find out more about different +rackup+ options:

<shell>
$ rackup --help
</shell>

h3. 动作控制器中间件堆栈Action Controller Middleware Stack

许多行动控制器的内部组件是作为 Rack 中间件实现的。 +ActionController::Dispatcher+ 使用 +ActionController::MiddlewareStack+ 结合各种内部和外部的中间件，形成一个完整的 Rails Rack 应用。Many of Action Controller's internal components are implemented as Rack middlewares. +ActionController::Dispatcher+ uses +ActionController::MiddlewareStack+ to combine various internal and external middlewares to form a complete Rails Rack application.

NOTE: Rails 的 +ActionController::MiddlewareStack+ 相当于 +Rack::Builder+ ，但具有更好的灵活性和更多的功能，以满足 Rails 的需求。+ActionController::MiddlewareStack+ is Rails' equivalent of +Rack::Builder+, but built for better flexibility and more features to meet Rails' requirements.

h4. 检查中间件堆栈Inspecting Middleware Stack

Rails 为检查中使用的中间件堆栈提供了方便的 rake task ：Rails has a handy rake task for inspecting the middleware stack in use:

<shell>
$ rake middleware
</shell>

对于一个新生成的 Rails 应用程序，可能会有类似输出：For a freshly generated Rails application, this might produce something like:

<ruby>
use ActionDispatch::Static
use Rack::Lock
use ActiveSupport::Cache::Strategy::LocalCache
use Rack::Runtime
use Rails::Rack::Logger
use ActionDispatch::ShowExceptions
use ActionDispatch::DebugExceptions
use ActionDispatch::RemoteIp
use Rack::Sendfile
use ActionDispatch::Callbacks
use ActiveRecord::ConnectionAdapters::ConnectionManagement
use ActiveRecord::QueryCache
use ActionDispatch::Cookies
use ActionDispatch::Session::CookieStore
use ActionDispatch::Flash
use ActionDispatch::ParamsParser
use Rack::MethodOverride
use ActionDispatch::Head
use ActionDispatch::BestStandardsSupport
run Blog::Application.routes
</ruby>

每个中间件的用途在"内部中间件":#internal-middleware-stack 一节中解释。Purpose of each of this middlewares is explained in the "Internal Middlewares":#internal-middleware-stack section.

h4. 配置中间件堆栈Configuring Middleware Stack

Rails 提供了一个简单的配置接口 +config.middleware+ 来添加，删除和修改在中间件堆栈中的中间件，通过 +application.rb+ 或特定环境配置文件 <tt>environments/&lt;environment&gt;.rb</tt> 。Rails provides a simple configuration interface +config.middleware+ for adding, removing and modifying the middlewares in the middleware stack via +application.rb+ or the environment specific configuration file <tt>environments/&lt;environment&gt;.rb</tt>.

h5. 添加一个中间件Adding a Middleware

你可以添加一个新的中间件到中间件堆栈中，使用下列任何一种方法：You can add a new middleware to the middleware stack using any of the following methods:

* <tt>config.middleware.use(new_middleware, args)</tt> - 添加新的中间件到中间件栈底。* <tt>config.middleware.use(new_middleware, args)</tt> - Adds the new middleware at the bottom of the middleware stack.

* <tt>config.middleware.insert_before(existing_middleware, new_middleware, args)</tt> - 添加新的中间件到指定的中间件堆栈中现有的中间件前。* <tt>config.middleware.insert_before(existing_middleware, new_middleware, args)</tt> - Adds the new middleware before the specified existing middleware in the middleware stack.

* <tt>config.middleware.insert_after(existing_middleware, new_middleware, args)</tt> - 添加新的中间件到指定的中间件堆栈中现有的中间件后。* <tt>config.middleware.insert_after(existing_middleware, new_middleware, args)</tt> - Adds the new middleware after the specified existing middleware in the middleware stack.

<ruby>
# config/application.rb

# 将 Rack::BounceFavicon 推到栈底
config.middleware.use Rack::BounceFavicon

# 添加 Lifo::Cache 到 ActiveRecord::QueryCache 之后
# 传递 { :page_cache => false } 参数到 Lifo::Cache.
config.middleware.insert_after ActiveRecord::QueryCache, Lifo::Cache, :page_cache => false
</ruby>

h5. 交换中间件Swapping a Middleware

你可以使用 +config.middleware.swap+ 交换现有的中间件中间件堆栈。You can swap an existing middleware in the middleware stack using +config.middleware.swap+.

<ruby>
# config/application.rb

# 替换 ActionController::Failsafe 为 Lifo::Failsafe
config.middleware.swap ActionController::Failsafe, Lifo::Failsafe
</ruby>

h5. 中间件堆栈是一个数组Middleware Stack is an Array

中间件堆栈的行为就像一个正常的 +Array+ 。你可以使用任何 +Array+ 方法来插入，重新排列，或从堆栈中删除项目。在上一节所述的方法是只是便捷的方法。The middleware stack behaves just like a normal +Array+. You can use any +Array+ methods to insert, reorder, or remove items from the stack. Methods described in the section above are just convenience methods.

例如，下面语句删除匹配所提供类名的中间件：For example, the following removes the middleware matching the supplied class name:

<ruby>
config.middleware.delete(middleware)
</ruby>

h4. 内部中间件Internal Middleware Stack

动作控制器的功能，大部分是作为中间件实现。下表说明了它们各自的用途：Much of Action Controller's functionality is implemented as Middlewares. The following table explains the purpose of each of them:

|_.中间件Middleware|_.用途Purpose|
|+Rack::Lock+|设定 <tt>env["rack.multithread"]</tt> 标志为 +true+ 并包裹应用到一个 Mutex 中。Sets <tt>env["rack.multithread"]</tt> flag to +true+ and wraps the application within a Mutex.|
|+ActionController::Failsafe+|如果一个分发时抛出异常，返回 HTTP 状态 +500+ 到客户端。Returns HTTP Status +500+ to the client if an exception gets raised while dispatching.|
|+ActiveRecord::QueryCache+|启用 Active Record 查询缓冲。Enables the Active Record query cache.|
|+ActionDispatch::Session::CookieStore+|使用基于 cookie 的会话存储。Uses the cookie based session store.|
|+ActionDispatch::Session::CacheStore+|使用基于 Rails 缓存的会话存储。Uses the Rails cache based session store.|
|+ActionDispatch::Session::MemCacheStore+|使用基于 memcached 的会话存储。Uses the memcached based session store.|
|+ActiveRecord::SessionStore+|使用基于数据库的会话存储。Uses the database based session store.|
|+Rack::MethodOverride+|基于 +_method+ 参数或 <tt>env["HTTP_X_HTTP_METHOD_OVERRIDE"]</tt> 设定 HTTP 方法。Sets HTTP method based on +_method+ parameter or <tt>env["HTTP_X_HTTP_METHOD_OVERRIDE"]</tt>.|
|+Rack::Head+|如果客户端发送 +HEAD+ 请求则丢弃响应体。Discards the response body if the client sends a +HEAD+ request.|

TIP: 您可以使用任意上述中间件在您的定制 Rack 堆栈中。It's possible to use any of the above middlewares in your custom Rack stack.

h4. 定制内部中间件堆栈Customizing Internal Middleware Stack

使用自定义堆栈取代整个中间件堆栈是可能的，<tt>ActionController::Dispatcher.middleware=</tt> 。It's possible to replace the entire middleware stack with a custom stack using <tt>ActionController::Dispatcher.middleware=</tt>.

把下面的内容放入 initializer 中：Put the following in an initializer:

<ruby>
# config/initializers/stack.rb
ActionController::Dispatcher.middleware = ActionController::MiddlewareStack.new do |m|
  m.use ActionController::Failsafe
  m.use ActiveRecord::QueryCache
  m.use Rack::Head
end
</ruby>

现在检查中间件堆栈：And now inspecting the middleware stack:

<shell>
$ rake middleware
(in /Users/lifo/Rails/blog)
use ActionController::Failsafe
use ActiveRecord::QueryCache
use Rack::Head
run ActionController::Dispatcher.new
</shell>

h4. 使用 Rack Builder Using Rack Builder

下面显示了如何替换使用 +Rack::Builder+ ，而不是 Rails 提供的 +MiddlewareStack+ 。The following shows how to replace use +Rack::Builder+ instead of the Rails supplied +MiddlewareStack+.

<strong>清除现有的 Rails 中间件堆栈Clear the existing Rails middleware stack</strong>

<ruby>
# config/application.rb
config.middleware.clear
</ruby>

<br />
<strong>添加一个 +config.ru+ 文件到 +Rails.root+ Add a +config.ru+ file to +Rails.root+</strong>

<ruby>
# config.ru
use MyOwnStackFromScratch
run ActionController::Dispatcher.new
</ruby>

h3. 资源Resources

h4. 学习 Rack Learning Rack

* "Rack 官方网站":http://rack.github.com
* "Rack 简介":http://chneukirchen.org/blog/archive/2007/02/introducing-rack.html
* "Ruby on Rack #1 - Hello Rack!":http://m.onkey.org/ruby-on-rack-1-hello-rack
* "Ruby on Rack #2 - The Builder":http://m.onkey.org/ruby-on-rack-2-the-builder

h4. 理解中间件Understanding Middlewares

* "Rack 中间件的 Railscast":http://railscasts.com/episodes/151-rack-middleware
