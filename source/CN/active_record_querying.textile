h2. Active Record 查询接口

本指导手册涉及了如何使用 Active Record 从数据库中取数据。通过本指导手册，你可以了解到：

* 使用多种方法和条件查找数据
* 对查找到的数据进行排序，分组，检索字段或者其它属性值
* 利用预加载来减少数据检索时的数据库查询数目
* 使用动态查找方法
* 检查是否存在某些记录
* Active Record 记录的计算方法
* 针对记录之间的关系执行 EXPLAIN

endprologue.

WARNING. 这个指导手册是基于 Rails 3.0 的。这里提到的某些代码在其它版本中可能不能工作。

如果你过去常常使用原始 SQL 来从数据库中查找数据，那你会发现在 Rails 中，你可以使用更好的方式来达到目的。Active Record 使你可以在大多数情况下都避免使用原始 SQL 语句。

本指导手册中的示例代码会使用如下几个 models ：
 
TIP： 除非具体指明，否则以下所有的 models 都使用 +id+ 作为主键。

<ruby>
class Client < ActiveRecord::Base
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
end
</ruby>

<ruby>
class Address < ActiveRecord::Base
  belongs_to :client
end
</ruby>

<ruby>
class Order < ActiveRecord::Base
  belongs_to :client, :counter_cache => true
end
</ruby>

<ruby>
class Role < ActiveRecord::Base
  has_and_belongs_to_many :clients
end
</ruby>

Active Record 可以帮你查询数据库并且兼容大多数数据库（ MySQL ， PostgreSQL 和  SQLite 等等）。不管你使用的是什么数据库， Active Record 的方法格式都是一样的。

h3. 从数据库中取对象

为了从数据库中取得对象， Active Record 提供了很多查询方法。每个查询方法都可以通过传递参数来精确控制查询而不需要书写原始 SQL 语句。

这些方法有：

* +where+
* +select+
* +group+
* +order+
* +reorder+
* +reverse_order+
* +limit+
* +offset+
* +joins+
* +includes+
* +lock+
* +readonly+
* +from+
* +having+

上面的所有方法都返回一个 <tt>ActiveRecord::Relation</tt> 实例。

<tt>Model.find(options)</tt> 的主要操作可以概括如下：

* 根据参数生成相应的 SQL 查询语句。
* 执行 SQL 查询并返回符合条件的结果。
* 为每个结果行实例化该 Model 的对象。
* 如果有的话，执行 +after_find+ 的回调函数。

h4. 检索单个对象

Active Record 提供了五种方式来检索单个对象。

h5. 使用主键

使用 <tt>Model.find(primary_key)</tt> ，你可以找到主键等于 _primay key_ 的记录。比如：

<ruby>
# 查找主键（ id ）等于 10 的 client 记录。
client = Client.find(10)
# => #<Client id: 10, first_name: "Ryan">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
</sql>

如果找不到匹配的记录 <tt>Model.find(primary_key)</tt> 会抛出一个 +ActiveRecord::RecordNotFound+ 异常。

h5. +first+

如果存在， <tt>Model.first</tt> 会返回该 Model 的第一条记录（根据主键升序排列）。比如：

<ruby>
client = Client.first
# => #<Client id: 1, first_name: "Lifo">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients LIMIT 1
</sql>

如果没找到匹配的记录， <tt>Model.first</tt> 会返回 nil 。它不会抛出异常。

h5. +last+

如果存在， <tt>Model.last</tt> 返回该 Model 的最后一条记录（根据主键升序排列）。 比如：

<ruby>
client = Client.last
# => #<Client id: 221, first_name: "Russel">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients ORDER  BY clients.id DESC LIMIT 1
</sql>

如果没找到匹配的记录， <tt>Model.last</tt> 会返回 nil 。它不会抛出异常。

h5(#first_1). +first!+

<tt>Model.first!</tt> 返回第一条记录。比如：

<ruby>
client = Client.first!
# => #<Client id: 1, first_name: "Lifo">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients LIMIT 1
</sql>

如果没有找到匹配的记录， <tt>Model.first!</tt> 会抛出 +RecordNotFound+ 异常。


h5(#last_1). +last!+

<tt>Model.last!</tt> 返回第一条记录。比如：

<ruby>
client = Client.last!
# => #<Client id: 221, first_name: "Russel">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
</sql>

如果没有找到匹配的记录， <tt>Model.last!</tt> 会抛出 +RecordNotFound+ 异常。

h4. 检索多条记录

h5. 使用多个主键

<tt>Model.find(array_of_primary_key)</tt> 接受一组 _primary keys_ 作为参数，返回一个包含所有匹配的记录的数组。比如：

<ruby>
# 查找主键是 1 或者 10 的 clients 。
client = Client.find([1, 10]) # 甚至可以这样写 Client.find(1, 10)
# => [#<Client id: 1, first_name: "Lifo">, #<Client id: 10, fist_name: "Ryan">]
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients WHERE (clients.id in (1, 10))
</sql>

WARNING: 除非所有的主键都找到匹配的记录，否则 <tt>Model.find(array_of_primary_key)</tt> 将会抛出一个 +ActiveRecord::RecordNotFound+ 异常。

h4. 按组检索多条记录

我们经常需要同时处理大量数据，比如说当我们需要实时通知一群用户时，或者载入数据时。

它可能直接这样写：

<ruby>
# 当 users 这个表有几千条数据时，效率会很低。
User.all.each do |user|
  NewsLetter.weekly_deliver(user)
end
</ruby>



