h2. Active Record 查询接口

本指导手册涉及了如何使用 Active Record 从数据库中取数据。通过本指导手册，你可以了解到：

* 使用多种方法和条件查找数据
* 对查找到的数据进行排序，分组，检索字段或者其它属性值
* 利用预加载来减少数据检索时的数据库查询数目
* 使用动态查找方法
* 检查是否存在某些记录
* Active Record 记录的计算方法
* 针对记录之间的关系执行 EXPLAIN

endprologue.

WARNING. 这个指导手册是基于 Rails 3.0 的。这里提到的某些代码在其它版本中可能不能工作。

如果你过去常常使用原始 SQL 来从数据库中查找数据，那你会发现在 Rails 中，你可以使用更好的方式来达到目的。Active Record 使你可以在大多数情况下都避免使用原始 SQL 语句。

本指导手册中的示例代码会使用如下几个 models ：
 
TIP： 除非具体指明，否则以下所有的 models 都使用 +id+ 作为主键。

<ruby>
class Client < ActiveRecord::Base
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
end
</ruby>

<ruby>
class Address < ActiveRecord::Base
  belongs_to :client
end
</ruby>

<ruby>
class Order < ActiveRecord::Base
  belongs_to :client, :counter_cache => true
end
</ruby>

<ruby>
class Role < ActiveRecord::Base
  has_and_belongs_to_many :clients
end
</ruby>

Active Record 可以帮你查询数据库并且兼容大多数数据库（ MySQL ， PostgreSQL 和  SQLite 等等）。不管你使用的是什么数据库， Active Record 的方法格式都是一样的。

h3. 从数据库中取对象

为了从数据库中取得对象， Active Record 提供了很多查询方法。每个查询方法都可以通过传递参数来精确控制查询而不需要书写原始 SQL 语句。

这些方法有：

* +where+
* +select+
* +group+
* +order+
* +reorder+
* +reverse_order+
* +limit+
* +offset+
* +joins+
* +includes+
* +lock+
* +readonly+
* +from+
* +having+

上面的所有方法都返回一个 <tt>ActiveRecord::Relation</tt> 实例。

<tt>Model.find(options)</tt> 的主要操作可以概括如下：

* 根据参数生成相应的 SQL 查询语句。
* 执行 SQL 查询并返回符合条件的结果。
* 为每个结果行实例化该 Model 的对象。
* 如果有的话，执行 +after_find+ 的回调函数。

h4. 检索单个对象

Active Record 提供了五种方式来检索单个对象。

h5. 使用主键

使用 <tt>Model.find(primary_key)</tt> ，你可以找到主键等于 _primay key_ 的记录。比如：

<ruby>
# 查找主键（ id ）等于 10 的 client 记录。
client = Client.find(10)
# => #<Client id: 10, first_name: "Ryan">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
</sql>

如果找不到匹配的记录 <tt>Model.find(primary_key)</tt> 会抛出一个 +ActiveRecord::RecordNotFound+ 异常。

h5. +first+

如果存在， <tt>Model.first</tt> 会返回该 Model 的第一条记录（根据主键升序排列）。比如：

<ruby>
client = Client.first
# => #<Client id: 1, first_name: "Lifo">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients LIMIT 1
</sql>

如果没找到匹配的记录， <tt>Model.first</tt> 会返回 nil 。它不会抛出异常。

h5. +last+

如果存在， <tt>Model.last</tt> 返回该 Model 的最后一条记录（根据主键升序排列）。 比如：

<ruby>
client = Client.last
# => #<Client id: 221, first_name: "Russel">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients ORDER  BY clients.id DESC LIMIT 1
</sql>

如果没找到匹配的记录， <tt>Model.last</tt> 会返回 nil 。它不会抛出异常。

h5(#first_1). +first!+

<tt>Model.first!</tt> 返回第一条记录。比如：

<ruby>
client = Client.first!
# => #<Client id: 1, first_name: "Lifo">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients LIMIT 1
</sql>

如果没有找到匹配的记录， <tt>Model.first!</tt> 会抛出 +RecordNotFound+ 异常。


h5(#last_1). +last!+

<tt>Model.last!</tt> 返回第一条记录。比如：

<ruby>
client = Client.last!
# => #<Client id: 221, first_name: "Russel">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
</sql>

如果没有找到匹配的记录， <tt>Model.last!</tt> 会抛出 +RecordNotFound+ 异常。

h4. 检索多条记录

h5. 使用多个主键

<tt>Model.find(array_of_primary_key)</tt> 接受一组 _primary keys_ 作为参数，返回一个包含所有匹配的记录的数组。比如：

<ruby>
# 查找主键是 1 或者 10 的 clients 。
client = Client.find([1, 10]) # 甚至可以这样写 Client.find(1, 10)
# => [#<Client id: 1, first_name: "Lifo">, #<Client id: 10, fist_name: "Ryan">]
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients WHERE (clients.id in (1, 10))
</sql>

WARNING: 除非所有的主键都找到匹配的记录，否则 <tt>Model.find(array_of_primary_key)</tt> 将会抛出一个 +ActiveRecord::RecordNotFound+ 异常。

h4. 按组检索多条记录

我们经常需要同时处理大量数据，比如说当我们需要实时通知一群用户时，或者载入数据时。

它可能直接这样写：

<ruby>
# 当 users 这个表有几千条数据时，效率会很低。
User.all.each do |user|
  NewsLetter.weekly_deliver(user)
end
</ruby>

但是随着表的规模的增大，这种处理过程也会随之增长。因为 +User.all.each+ 一次性地将整个表都实例化了，为每一条记录生成了一个 model ，并把这个结果数组保存在内存中。确实，当我们有一堆非常巨大的对象时，这个集合将会导致内存溢出。

Rails 提供了两种方法来把记录分割成组进行处理。第一种方法是 +find_each+ ，检索出一组数据并对将每条记录作为一个 model 传给 block 代码块。第二种方法是 +find_in_batches+ ，检索出一组数据然后将整组数据作为一个 model 的数组传给 block 代码块。

TIP: 这里的 +find_each+ 和 +find_in_batches+ 方法适用于那种大量数据不能够一次加载到内存中的情况分组处理情况。如果你只是想遍历一千条数据，那一般的查找方法会更好。

h5. +find_each+

这个 +find_each+ 方法检索出一组数据并对将每条记录作为一个 model 传给 block 代码块。在下面的例子中， +find_each+ 方法会检索出 1000 条数据（当前的 +find_each+ 和 +find_in_batches+ 方法的默认值）然后将每条记录作为一个 model 传给 block 代码块。

<ruby>
User.find_each do |user|
  NewsLetter.weekly_deliver(user)
end
</ruby>

h6. +find_each+ 的参数

+find_each+ 方法可以接受除了 +:order+ 和 +:limit+ 之外的普通的 +find+ 的大部分参数，而 +:order+ 和 +:limit+ 已经在 +find_each+ 方法内部实现使用了。

另外，+find_each+ 还可以接受两个额外的参数 +:batch_size+ 和 +:start+ 。

*+:batch_size+*

+:batch_size+ 这个参数可以让你在传递给 block 语句块之前指定检索到的每组数据的记录数目。比如说，检索一个 5000 条数据的组：

<ruby>
User.find_each(:batch_size => 5000) do |user|
  NewsLetter.weekly_deliver(user)
end
</ruby>

*+:start+*

默认情况下，我们根据主键的递增顺序取数据，因为主键肯定是一个正整数。当你不需要低于某个 ID 值以下的记录时， +:start+ 这个参数让你可以指定开始的 ID 值，比如说：如果你想继续一个中断的处理进程，你就可以提供你最后一个保存的记录 ID 来实现。

比如说： 只对记录 ID 大于 2000 的用户发送新闻信件（ newsletters ），并且按照每组 5000 条记录查询：

<ruby>
User.find_each(:start => 2000, :batch_size => 5000) do |user|
  NewLetter.weekly_deliver(user)
end
</ruby>

另外一个例子是如果你想多个使用者（ workers ）使用相同的查询。你可以给每个使用者（ worker ）设置 <tt>:start</tt> 属性来处理 10000 条数据。

NOTE: +:include+ 可以让你定义与该记录一起加载的关联记录（ associations ）。

h5. +find_in_batches+

+find_in_batches+ 和 +find_each+ 很像，因为它们都是按组检索记录的。不同点在于 +find_in_batches+ 将整组数据作为一个 model 数组传给 block 语句块，而不是分开。下面的例子一次性将最多 1000 条 invoices 记录作为一个数组传递给 block 语句块，最后语句块中包含所有剩下的 invoices 记录。

<ruby>
# 一次性传递 1000 个 invoices 记录给 add_invoices 方法。
Invoice.find_in_batches(:include => :invoice_lines) do |invoices|
  export.add_invoices(invoices)
end
</ruby>

NOTE: +:include+ 可以让你定义与该记录一起加载的关联记录（ associations ）。

h6. +find_in_batches+ 的参数

+find_in_batches+ 方法也像 +find_each+ 方法一样接受 +:batch_size+ 和 +:start+ 这两个参数，同时也接受大部分普通 +find+ 方法的参数，除了 +:order+ 和 +:limit+ 这两个 +find_in_batches+ 内部实现使用了的参数。
