h2. Active Record 查询接口

本指导手册涉及了如何使用 Active Record 从数据库中取数据。通过本指导手册，你可以了解到：

* 使用多种方法和条件查找数据
* 对查找到的数据进行排序，分组，检索字段或者其它属性值
* 利用预加载来减少数据检索时的数据库查询数目
* 使用动态查找方法
* 检查是否存在某些记录
* Active Record 记录的计算方法
* 在 relation 实例对象上执行 EXPLAIN

endprologue.

WARNING. 这个指导手册是基于 Rails 3.0 的。这里提到的某些代码在其它版本中可能不能工作。

如果你过去常常使用原始 SQL 来从数据库中查找数据，那你会发现在 Rails 中，你可以使用更好的方式来达到目的。Active Record 使你可以在大多数情况下都避免使用原始 SQL 语句。

本指导手册中的示例代码会使用如下几个 models ：
 
TIP： 除非具体指明，否则以下所有的 models 都使用 +id+ 作为主键。

<ruby>
class Client < ActiveRecord::Base
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
end
</ruby>

<ruby>
class Address < ActiveRecord::Base
  belongs_to :client
end
</ruby>

<ruby>
class Order < ActiveRecord::Base
  belongs_to :client, :counter_cache => true
end
</ruby>

<ruby>
class Role < ActiveRecord::Base
  has_and_belongs_to_many :clients
end
</ruby>

Active Record 可以帮你查询数据库并且兼容大多数数据库（ MySQL ， PostgreSQL 和  SQLite 等等）。不管你使用的是什么数据库， Active Record 的方法格式都是一样的。

h3. 从数据库中取对象

为了从数据库中取得对象， Active Record 提供了很多查询方法。每个查询方法都可以通过传递参数来精确控制查询而不需要书写原始 SQL 语句。

这些方法有：

* +where+
* +select+
* +group+
* +order+
* +reorder+
* +reverse_order+
* +limit+
* +offset+
* +joins+
* +includes+
* +lock+
* +readonly+
* +from+
* +having+

上面的所有方法都返回一个 <tt>ActiveRecord::Relation</tt> 实例。

<tt>Model.find(options)</tt> 的主要操作可以概括如下：

* 根据参数生成相应的 SQL 查询语句。
* 执行 SQL 查询并返回符合条件的结果。
* 为每个结果行实例化该 Model 的对象。
* 如果有的话，执行 +after_find+ 的回调函数。

h4. 检索单个对象

Active Record 提供了五种方式来检索单个对象。

h5. 使用主键

使用 <tt>Model.find(primary_key)</tt> ，你可以找到主键等于 _primay key_ 的记录。比如：

<ruby>
# 查找主键（ id ）等于 10 的 client 记录。
client = Client.find(10)
# => #<Client id: 10, first_name: "Ryan">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
</sql>

如果找不到匹配的记录 <tt>Model.find(primary_key)</tt> 会抛出一个 +ActiveRecord::RecordNotFound+ 异常。

h5. +first+

如果存在， <tt>Model.first</tt> 会返回该 Model 的第一条记录（根据主键升序排列）。比如：

<ruby>
client = Client.first
# => #<Client id: 1, first_name: "Lifo">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients LIMIT 1
</sql>

如果没找到匹配的记录， <tt>Model.first</tt> 会返回 nil 。它不会抛出异常。

h5. +last+

如果存在， <tt>Model.last</tt> 返回该 Model 的最后一条记录（根据主键升序排列）。 比如：

<ruby>
client = Client.last
# => #<Client id: 221, first_name: "Russel">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients ORDER  BY clients.id DESC LIMIT 1
</sql>

如果没找到匹配的记录， <tt>Model.last</tt> 会返回 nil 。它不会抛出异常。

h5(#first_1). +first!+

<tt>Model.first!</tt> 返回第一条记录。比如：

<ruby>
client = Client.first!
# => #<Client id: 1, first_name: "Lifo">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients LIMIT 1
</sql>

如果没有找到匹配的记录， <tt>Model.first!</tt> 会抛出 +RecordNotFound+ 异常。


h5(#last_1). +last!+

<tt>Model.last!</tt> 返回第一条记录。比如：

<ruby>
client = Client.last!
# => #<Client id: 221, first_name: "Russel">
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
</sql>

如果没有找到匹配的记录， <tt>Model.last!</tt> 会抛出 +RecordNotFound+ 异常。

h4. 检索多条记录

h5. 使用多个主键

<tt>Model.find(array_of_primary_key)</tt> 接受一组 _primary keys_ 作为参数，返回一个包含所有匹配的记录的数组。比如：

<ruby>
# 查找主键是 1 或者 10 的 clients 。
client = Client.find([1, 10]) # 甚至可以这样写 Client.find(1, 10)
# => [#<Client id: 1, first_name: "Lifo">, #<Client id: 10, fist_name: "Ryan">]
</ruby>

等价的 SQL 语句是：

<sql>
SELECT * FROM clients WHERE (clients.id in (1, 10))
</sql>

WARNING: 除非所有的主键都找到匹配的记录，否则 <tt>Model.find(array_of_primary_key)</tt> 将会抛出一个 +ActiveRecord::RecordNotFound+ 异常。

h4. 按组检索多条记录

我们经常需要同时处理大量数据，比如说当我们需要实时通知一群用户时，或者载入数据时。

它可能直接这样写：

<ruby>
# 当 users 这个表有几千条数据时，效率会很低。
User.all.each do |user|
  NewsLetter.weekly_deliver(user)
end
</ruby>

但是随着表的规模的增大，这种处理过程也会随之增长。因为 +User.all.each+ 一次性地将整个表都实例化了，为每一条记录生成了一个 model ，并把这个结果数组保存在内存中。确实，当我们有一堆非常巨大的对象时，这个集合将会导致内存溢出。

Rails 提供了两种方法来把记录分割成组进行处理。第一种方法是 +find_each+ ，检索出一组数据并对将每条记录作为一个 model 传给 block 代码块。第二种方法是 +find_in_batches+ ，检索出一组数据然后将整组数据作为一个 model 的数组传给 block 代码块。

TIP: 这里的 +find_each+ 和 +find_in_batches+ 方法适用于那种大量数据不能够一次加载到内存中的情况分组处理情况。如果你只是想遍历一千条数据，那一般的查找方法会更好。

h5. +find_each+

这个 +find_each+ 方法检索出一组数据并对将每条记录作为一个 model 传给 block 代码块。在下面的例子中， +find_each+ 方法会检索出 1000 条数据（当前的 +find_each+ 和 +find_in_batches+ 方法的默认值）然后将每条记录作为一个 model 传给 block 代码块。

<ruby>
User.find_each do |user|
  NewsLetter.weekly_deliver(user)
end
</ruby>

h6. +find_each+ 的参数

+find_each+ 方法可以接受除了 +:order+ 和 +:limit+ 之外的普通的 +find+ 的大部分参数，而 +:order+ 和 +:limit+ 已经在 +find_each+ 方法内部实现使用了。

另外，+find_each+ 还可以接受两个额外的参数 +:batch_size+ 和 +:start+ 。

*+:batch_size+*

+:batch_size+ 这个参数可以让你在传递给 block 语句块之前指定检索到的每组数据的记录数目。比如说，检索一个 5000 条数据的组：

<ruby>
User.find_each(:batch_size => 5000) do |user|
  NewsLetter.weekly_deliver(user)
end
</ruby>

*+:start+*

默认情况下，我们根据主键的递增顺序取数据，因为主键肯定是一个正整数。当你不需要低于某个 ID 值以下的记录时， +:start+ 这个参数让你可以指定开始的 ID 值，比如说：如果你想继续一个中断的处理进程，你就可以提供你最后一个保存的记录 ID 来实现。

比如说： 只对记录 ID 大于 2000 的用户发送新闻信件（ newsletters ），并且按照每组 5000 条记录查询：

<ruby>
User.find_each(:start => 2000, :batch_size => 5000) do |user|
  NewLetter.weekly_deliver(user)
end
</ruby>

另外一个例子是如果你想多个使用者（ workers ）使用相同的查询。你可以给每个使用者（ worker ）设置 <tt>:start</tt> 属性来处理 10000 条数据。

NOTE: +:include+ 可以让你定义与该记录一起加载的关联记录（ associations ）。

h5. +find_in_batches+

+find_in_batches+ 和 +find_each+ 很像，因为它们都是按组检索记录的。不同点在于 +find_in_batches+ 将整组数据作为一个 model 数组传给 block 语句块，而不是分开。下面的例子一次性将最多 1000 条 invoices 记录作为一个数组传递给 block 语句块，最后语句块中包含所有剩下的 invoices 记录。

<ruby>
# 一次性传递 1000 个 invoices 记录给 add_invoices 方法。
Invoice.find_in_batches(:include => :invoice_lines) do |invoices|
  export.add_invoices(invoices)
end
</ruby>

NOTE: +:include+ 可以让你定义与该记录一起加载的关联记录（ associations ）。

h6. +find_in_batches+ 的参数

+find_in_batches+ 方法也像 +find_each+ 方法一样接受 +:batch_size+ 和 +:start+ 这两个参数，同时也接受大部分普通 +find+ 方法的参数，除了 +:order+ 和 +:limit+ 这两个 +find_in_batches+ 内部实现使用了的参数。

h3. 条件表达式

+where+ 方法让你可以限制返回的结果集，它代表了 SQL 语句的 +where+ 部分。条件可以是一个字符串、一个数组或者是一个映射表。

h4. 仅含有字符串的条件表达式

如果你想在普通查找方法里面加上条件表达式，那你可以直接这样写， +Client.where("orders_count = '2'")+ 。它会返回所有的 +orders_counts+ 为 2 的 clients 记录。

WARNING: 直接用字符串构造你的条件表达式可能会让你遭受到 SQL 注入攻击。比如说： +Client.where("first_name LIKE '%#{params[:first_name]}'")+ 就是不安全的。请看下一节如何使用数组更好地构造条件表达式。

h4. 数组条件表达式

假如数字会发生变化或者从其它地方传入，那该怎么办呢？那方法可能会写成如下形式：

<ruby>
Client.where("orders_count =?", params[:orders])
</ruby>

Active Record 会先检查第一个元素，并用后面的元素代替 +(?)+ 中的问号。

如果你需要多个条件表达式：

<ruby>
Client.where("orders_count = ? AND locked = ?", params[:orders], false)
</ruby>

在这个例子中，第一个问号会被 +params[:orders]+ 替代，第二个问号会被 +false+ 的的等价值代替，这取决于数据库。

所以，这种写法

<ruby>
Client.where("orders_count = ?", params[:orders])
</ruby>

比这种写法好。

<ruby>
Client.where("orders_count = #{params[:orders]}")
</ruby>

因为它是变量安全的。如果你直接把变量写在条件表达式里面，那它会毫不处理地把变量传递给数据库。这就意味着它可能是来自于某个恶意用户的不安全的变量。如果你这样做，那你的数据库就危险了，因为一旦某个用户发现了他可以利用你的数据库，他就可以对它做任何事。所以千万不要直接把变量写在条件表达式里面。

h5. 条件表达式中的占位符

就像 +(?)+ 代替变量一样，你也可以在数组形式的条件表达式里面使用键值对：

<ruby>
Client.where("created_at >= :start_date AND created_at <= :end_date", 
  {:start_date => params[:start_date], :end_date => params[:end_date]})
</ruby>

当你有一大堆变量时，这样的写法更具可读性。

h5(#array-range_conditions). 数列式条件表达式

如果你要查找一个表中的一段连续的记录（比如说，在确定的一段时间内创建的用户），你可以在原始 SQL 语句中直接使用 +in+ 配合条件表达式来达到目的。如果知道两个日期值，你也可以这样查找这些连续的记录。

<ruby>
Client.where(:created_at => (params[:start_date].to_date)..(params[:end_date].to_date))
</ruby>

这个查询会产生类似于如下的 SQL 语句：

<sql>
  SELECT "clients".* FROM "clients" WHERE ("clients"."created_at" BETWEEN '2010-09-29' AND '2010-11-30')
</sql>

h4. 映射表式条件表达式

Active Record 还支持传递一个映射表式条件表达式来提高你的条件表达式的可读性。在映射表式的条件表达式中，你把想比较的字段作为键，要用来比较的变量作为值。

NOTE: 映射表式的条件表达式只用于相等比较，排序和查找子集中。

h5. 等价条件表达式

<ruby>
Client.where(:locked => true)
</ruby>

字段名也可以是一个字符串：

<ruby>
Client.where('locked' => true)
</ruby>

h5(#hash-range_conditions). 数列式条件表达式

这种写法的好处是我们可以直接传一串变量而不需要像本节开头一样生成一个大大的查询语句。

<ruby>
Client.where(:created_at => (Time.now.midnight -1.day)..Time.now.midnight)
</ruby>

它会用以下含有 +BETWEEN+ 的 SQL 语句来找出所有昨天创建的 clients 记录：

<sql>
SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
</sql>

这个表达式是数组式条件表达式中的例子的简写。

h5. 子集条件表达式

如果你想使用 +IN+ 来查找记录，你可以传一个数组给映射表条件表达式：

<ruby>
Client.where(:orders_count => [1,3,5])
</ruby>

以上代码会产生类似于如下语句的的 SQL 表达式。

<sql>
SELECT * FROM clients WHERE (clients.orders_count in (1,3,5)
</sql>

h3. 排序

如果你想按照某种特定顺序返回检索的记录，可以使用 +order+ 方法。

比如：如果你有一组记录并且希望它们能够按照 +created_at+ 的升序排列：

<ruby>
Client.order("created_at")
</ruby>

你还可以指定 +ASC+ 或者 +DESC+ 。

<ruby>
Client.order("created_at DESC")
# 或者
Client.order("created_at ASC")
</ruby>

又或者是按照多个字段排序：

<ruby>
Client.order("orders_count ASC, created_at DESC")
# 或者
Client.order("orders_count ASC", "created_at DESC")
</ruby>

h3. 选择返回的字段（投影）

默认情况下， <tt>Model.find</tt> 方法使用 +select *+ 来返回结果记录的所有字段。

如果你要返回结果集的一个子集，那你可以通过 +select+ 方法来指定这个子集。

NOTE: 如果你使用了 +select+ 方法，那返回的集合是只读的：#只读对象。

<br />

比如：我们只需要 +viewable_by+ 和 +locked+ 两个字段：

<ruby>
Client.select("viewable_by, locked")
</ruby>

最终生成的 SQL 就会像下面一样：

<sql>
SELECT viewableby, locked FROM clients
</sql>

请特别小心，因为你这样只是初始化了一个 model 对象的一些字段。如果你操作那些你还未初始化的字段，那你就会得到一个异常：

<shell>
ActiveModel::MissingAttributeError: missing attribute: <attribute>
</shell>

其中 +<attribute>+ 是你要操作的属性名。+id+ 方法不会抛出 +ActiveRecord::MissingAttributeError+ ，所以在使用 model 的 associations 时要小心，因为它依赖于 +id+ 方法。

如果你想对于某个字段只返回不同的记录，你可以使用 +uniq+：

<ruby>
Client.select(:name).uniq
</ruby>

它会生成如下 SQL 语句：

<sql>
SELECT DISTINCT name FROM clients
</sql>

你也可以移除这个唯一性约束：

<ruby>
query = Client.select(:name).uniq
# => 返回唯一的 name 字段

query.uniq(false)
# => 返回所有 name ，即使有重复
</ruby>

h3. 限制和偏移量

如果你想在 +Model.find+ 中使用 +LIMIT+ 来限制结果，那你可以直接在 relation 实例对象上面结合使用 +limit+ 和 +offset+ 方法来指定 +LIMIT+ 。

你可以使用 +limit+ 来指定返回的结果集中记录数量，然后使用 +offset+ 来指定偏移的记录数目。比如：

<ruby>
Client.limit(5)
</ruby>

将会最多返回 5 条记录，并且因为没有偏移量，所以它会返回最前面的 5 条记录。它执行的 SQL 语句如下：

<sql>
SELECT * FROM clients LIMIT 5
</sql>

然后在其基础上增加 +offset+

<ruby>
Clients.limit(5).offset(30)
</ruby>

它会返回从第 31 条记录开始的最多 5 条记录。它相当于如下 SQL 语句：

<sql>
SELECT * FROM clients LIMIT 5 OFFSET 30
</sql>

h3. 分组

为了在查找记录的 SQL 语句中时指定 +GROUP BY+ ，你可以直接使用 +group+ 方法。

比如你想找一组记录并按照创建的时间排序：

<ruby>
Order.select("data(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)“)
</ruby>

它会为每个有 orders 的日期的返回一个 +Order+ 对象。

他将会生成如下一样的 SQL 语句：

<sql>
SELECT date(created_at) as ordered_date, sum(price) as total_price FROM orders GROUP BY date(created_at)
</sql>

h3. Having 语句

SQL 使用者利用 +HAVING+ 来指定 +GROUP BY+ 字段的需要满足的条件。你可以在 +Model.find+ 中将 +:having+ 作为一个参数传递给查找方法。

比如说：

<ruby>
Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)").having("sum(price) > ?", 100)
</ruby>

他将会生成如下 SQL 语句：

<sql>
SELECT date(created_at) as ordered_date, sum(price) as total_price FROM orders GROUP BY date(created_at) HAVING sum(price) > 100
</sql>

它会为每天返回一个 order 对象，但是仅限于那些一天订单总额大于 $100 的日子。

h3. 覆盖条件表达式

h4. +expect+

你可以使用 +expect+ 来忽略一些特定的条件表达式。比如说：

<ruby>
Post.where('id > 10').limit(20).order('id asc').expect(:order)
</ruby>

类似于如下的 SQL 将会被执行：

<sql>
SELECT * FROM posts WHERE id > 10 LIMIT 20
</sql>

h4. +only+

你还可以使用 +only+ 方法来覆盖一些条件表达式。比如说：

<ruby>
Post.where('id > 10').limit(20).order('id desc').only(:order, :where)
</ruby>

它会生成如下 SQL 语句：

<sql>
SELECT * FROM posts WHERE id > 10 ORDER BY id DESC
</sql>

h4. +reorder+

+reorder+ 方法会覆盖默认的排序方法。 比如说：

<ruby>
class Post < ActiveRecord::Base
  ..
  ..
  has_many :comments, :order => 'posted_at DESC'
end

Post.find(10).comments.reorder('name')
</ruby>

它会产生如下 SQL 语句：

<sql>
SELECT * FROM posts WHERE id = 10 ORDER BY name
</sql>

如果没有使用 +reorder+ 方法，那对应的 SQL 语句就会变为：

<sql>
SELECT * FROM posts WHERE id = 10 ORDER BY posted_at DESC
</sql>

h4. +reverse_order+

+reverse_order+ 方法会按照指定的排序方式倒序排列。

<ruby>
Client.where("orders_count > 10").order(:name).reverse_order
</ruby>

如下 SQL 语句将会执行：

<sql>
SELECT * FROM clients WHERE orders_count > 10 ORDER BY name DESC
</sql>

如果没有特别指定排序方式，那 +reverse_order+ 方法会按照主键的倒序排列。

<ruby>
Client.where("orders_count > 10").reverse_order
</ruby>

它将会产生如下 SQL 语句：

<sql>
SELECT * FROM clients WHERE orders_count > 10 ORDER BY clients.id DESC
</sql>

这个方法还接受 *no* 参数。

h3. 空 relation 实例对象

+none+ 方法会返回一个代表没有记录的 relation 实例对象。随后的条件表达式会根据这个 relation 实例对象继续返回空的 relation 实例对象而不是空结果时非常有用。

<ruby>
Post.none # 返回一个空结果并且不执行任何查询。
</ruby>

<ruby>
# 以下的 visible_posts 方法期望返回一个关系对象。
@posts = current_user.visible_posts.where(:name => params[:name])

def visible_posts
  case role
  when 'Country Manager'
    Post.where(:country => country)
  when 'Reviewer'
    Post.published
  when 'Bad User'
    Post.none # => 这里会返回一个 [] 或者 nil 并且结束调用
  end
end
</ruby>

h3. 只读的对象

Active Record 提供了 relation 实例对象上面的 +readonly+ 方法来明确指定不允许修改返回的对象。任何尝试修改只读对象行为都会失败，抛出一个 +ActiveRecord::ReadOnlyRecord+ 异常。

<ruby>
client = Client.readonly.first
client.visits += 1
client.save
</ruby>

因为 +client+ 已经被明确指定为一个只读的对象，所以以上的代码在执行 +client.save+ 时候更新 _visits_ 时会抛出一个 +ActiveRecord::ReadOnlyRecord+ 异常。

h3. 为更新对象加锁

加锁可以有效防止更新数据库记录时条件表达式竞争而保证更新操作的原子性。

Active Record 提供了两种加锁机制：

* 乐观锁
* 悲观锁

h4. 乐观锁

乐观锁允许多个用户同时修改同一个对象，它假定数据冲突发生的可能性极小。它检查是否有另外的进程在这个记录打开后修改了这个对象来实现加锁的目地。如果有，那他会抛出一个 +ActiveRecord::StaleObjectError+ 异常并且忽略更新操作。

<strong>乐观锁在列上加锁</strong>

为了使用乐观锁，数据表中必须有一个叫做 +lock_version+ 的字段。每次记录更新之后， Active Record 都会增加 +lock_version+ 的数值。如果一个更新请求的 +lock_version+ 数值小于数据库中的 +lock_version+ ，那更新就会失败，并且抛出一个 +ActiveRecord::StaleObjectError+ 。比如说：

<ruby>
ca = Client.find(1)
c2 = Client.find(1)

c1.first_name = "Michael"
c1.save

c2.name = "should fail"
c2.save # 抛出一个 ActiveRecord::StaleObjectError
</ruby>

然后你需要自己负责处理这个冲突，包括继续抛出异常并且回滚，合并或者提交其它业务逻辑以解决这个冲突。

如果你要关闭这个机制，可以这样设置： <tt>ActiveRecord::Base.lock_optimistically = false</tt> 。

+ActiveRecord::Base+ 也提供了一个类属性 +locking_column+ 来修改默认的 +lock_version+ 字段：

<ruby>
class Client < ActiveRecord::Base
  self.locking_column = :lock_client_column
end
</ruby>

h4. 悲观锁

悲观锁使用数据库提供的锁机制。当它使用 +lock+ 来构建一个 relation 实例对象时对返回的记录行加独占锁（写锁）。 relation 实例对象通常在一个事务里面使用 +lock+ 来防止发生死锁。

比如说：

<ruby>
Item.transaction do
  i = Item.lock.first
  i.name = 'Jones'
  i.save
end
</ruby>

上面的代码在 MySQL 作为后端数据库时会生成以下 SQL 语句：

<sql>
SQL (0.2ms) BEGIN
Item Load (0.3ms)  SELECT * FROM `item` LIMIT 1 FOR UPDATE
Item Update (0.4ms)  UPDATE `items` SET `updated_at` = `2009-02-07 18:05:56`, `name` = 'Jones' WHERE `id` = 1
SQL (0.8ms)  COMMIT
</sql>

你还可以传递原始 SQL 语句给 +lock+ 方法来支持不同类型的锁。比如说： MySQL 有一中锁叫做 +LOCK IN SHARE MODE+ ，它可以让你对一条记录上锁但是允许其它人读它。要指定这种锁类型，你需要把它作为参数传给 lock 方法：

<ruby>
Item.transaction do
  i = Item.lock("LOCK IN SHARE MODE").find(1)
  i.increament(:view)
end
</ruby>

如果你已经有一个对象实例了，你可以使用如下代码来一次性地开启一个事务并加锁。

<ruby>
item = Item.first
item.with_lock do
  # 这个代码块在事务里面执行
  # item 是已经加锁的
  item.increment!(:view)
end
</ruby>

h3. 连接表

Active Record 提供了一个叫做 +joins+ 的查找方法来对结果的 SQL 语句指定 +JOIN+ 子句。Active Record 提供了多种使用 +joins+ 方法的方式。

h4. 使用零碎的 SQL 语句

你可以使用原生态的 SQL 来使用 +JOIN+ 方法以生成 +joins+ 子句。

<ruby>
Client.join('LEFT OUTER JOIN addresses ON addresses.client_id = clients.id')
</ruby>

它会生成如下 SQL 语句：

<sql>
SELECT clients.* FROM clients LEFT OUTER JOIN addresses ON addresses.client_id = clients.id
</sql>

h4. 使用 Associations 的数组或者映射表

WARNING: 这个方法只适用于 +INTER JOIN+ 的情况。

Active Record 允许我们使用“ associations ”这个名字： model 中定义了 association_basic.html 作为使用 +JOIN+ 来指定 +joins+ 的缩写。

比如说：看如下关于 +Category+ ， +Post+ ， +Comments+ 和 +Guest+ 几个 model 的例子。

<ruby>
class Category < ActiveRecord::Base
  has_many :posts
end

class Post < ActiveRecord::Base
  belongs_to :category
  has_many :comments
  has_many :tags
end

class Comment < ActiveRecord::Base
  belongs_to :post
  has_one :guest
end

class Guest < ActiveRecord::Base
  belongs_to :comment
end

class Tag < ActiveRecord::Base
  belongs_to :post
end
</ruby>

现在以下所有的语句都会产生相应的使用了 +INNER JOIN+ 的连接查询语句：

h5. 使用单个 Association

<ruby>
Category.joins(:posts)
</ruby>

它会产生如下语句：

<sql>
SELECT categories.* FROM categories
  INNER JOIN posts ON posts.category_id = categories.id
</sql>

或者用英语说就是“ return a Category object for all categories with posts ”。注意如果你有多个 posts 关联相同的 category 的话，就会出现重复。如果你想消除重复， 那你可以这样写： Category.joins(:post).select("distinct(categories.id)") 。

h5. 使用多个 Association

<ruby>
Post.joins(:category, :comments)
</ruby>

它会产生这样的结果：

<sql>
SELECT posts.* FROM posts
  INNER JOIN categories ON posts.category_id = categories.id
  INNER JOIN comments ON comments.post_id = posts.id
</sql>

或者用英语说就是： “ return all posts that having a category and at least one comment ”。再次注意有多条 comment 记录的 post 会重复出现。

h5. 使用嵌套 Association （单层的）

<ruby>
Post.joins(:comments => :guest)
</ruby>

它会产生如下语句：

<sql>
SELECT posts.* FROM posts
  INNER JOIN comments ON comments.post_id = posts.id
  INNER JOIN guest ON guests.comment_id = comments.id
</sql>

同样，用英语说的就是： “ return all posts that have a comment made by guest. ”。

h5. 使用嵌套 Association （多层的）

<ruby>
Category.joins(:posts => [{:comments => :guest}, :tags])
</ruby>

它产生如下结果：

<sql>
SELECT categories.* FROM categories
  INNER JOIN posts ON posts.category_id = categories.id
  INNER JOIN comments ON comments.post_id = posts.id
  INNER JOIN guests ON guests.comment_id = comments.id
  INNER JOIN tags ON tags.post_id = posts.id
</sql>

h4. 指定连接表的条件表达式

你可以使用通常的"数组":#array-conditions 和 "字符串":#pure-string-conditions 条件表达式来直接指定连接表的条件表达式。"映射表条件表达式":#hash-conditions 需要用一种特殊的语法来指定。

<ruby>
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where('orders.created_at' => time_range)
<ruby>

另外一种更清晰的写法是使用映射表条件表达式

<ruby>
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where(:orders => {:created_at => time_range})
</ruby>

它会使用 +BETWEEN+ 关键字来找出所有昨天创建了 order 的 client 记录。

h3. 预加载 Association

预加载是一种预先加载可能被多个 +Model.find+ 都会使用到的关联记录的机制。

<strong>N <plus> 1 查询问题</strong>

看下面的代码：它找出 10 个 client 记录并打印出它们的 postcodes ：

<ruby>
clients = Client.limit(10)

clients.each do |client|
  puts client.address.postcode
end
</ruby>

第一眼看去，这个代码没什么问题。不幸的是：它的问题在于这段语句执行的查询次数。上面的代码总共执行了 1 （找出 10 条 client 记录） <plus> 10 （每次加载一次 address 记录） = <strong>11</strong> 次查询。

<strong>N <plus> 1 查询问题的解决方案</strong>

Active Record 允许你提前指定是否需要加载所有的 association 。你可以在调用 +Model.find+ 时候用 +includes+ 来指定它。如果使用了 +includes+ 方法， 那 Active Record 保证在最少次数内加载所有的指定的 associations 。

再来看上面的问题，我们可以在使用 +Client.all+ 时预先加载 address 。

<ruby>
clients - Client.includes(:address).limit(10)

client.each do |client|
  puts client.address.postcode
end
</ruby>

相对于之前的代码的 <strong>11</strong> 次查询，以上的代码只需要执行 <strong>2</strong> 次查询。

<sql>
SELECT * FROM clients LIMIT 10
SELECT addresses.* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
</sql>

h4. 预加载多个 Association

Active Record 允许你在一次 +Model.find+ 调用中使用 +include+ 方法通过数组，映射表或者嵌套的数组/映射表的方式来加载任意多个 association 。

h5. 多个 Association 的数组

<ruby>
Post.includes(:category, :comments)
</ruby>

它会载入所有的 post 和与之关联的 category 和 comment 记录。

h5. 嵌套的 Association 映射表

<ruby>
Category.includes(:posts => [{:comments => :guest}, :tags).find(1)
</ruby>

它会返回 id 为 1 的 category 记录并预先加载与之相关联的 post 记录，与 post 相关联的 tag 和 comment 记录和与 comment 相关联的 guest 记录。

h4. 为预加载的 Association 指定条件表达式

尽管 Active Record 像给 +joins+ 一样给预加载的 association 也提供了指定条件表达式的方法，但我们建议使用 "joins":#joining-tables 来代替。

然后，如果你还是要这样做，那么你可以想你平时一样使用 +where+ 来达到目的。

<ruby>
Post.includes(:comments).where("comments.visible", true)
</ruby>

它会产生一个包含 +LEFT OUTER JOIN+ 查询语句，而 +joins+ 语句产生的语句包含的是 +INNER JOIN+ 。

<sql>
  SELECT "posts"."id" AS t0_r0, ... "comments"."updated_at" AS t1_r5 FROM "posts" LEFT OUTER JOIN "comments" ON "comments"."post_id" = "posts"."id" WHERE (comments.visible = 1)
</ruby>

如果没有 +where+ 语句，那会生成两条普通的查询语句。

如果在 +includes+ 的查询时， post 没有任何 comment ，那依然会加载所有的 post 记录。如果使用 +joins+ （使用 INNER JOIN ），那就不会返回任何记录。

h3. Scopes

scope 让你可以指定常用的 Arel 查询以便于 association 对象和 model 的调用。在这些 scope 中，你可以使用之前提到过得任何方法，比如： +where+ ， +joins+ 和 +includes+ 。所有的 scope 方法都会返回一个 +ActiveRecord::Relation+ 对象，这个对象可以进一步调用其它方法（包括其它 scope ）。

定义一个简单的 scope ，我们只需在类里面给 +scope+ 方法传递我们希望执行的 Arel 查询就可以了：

<ruby>
class Post < ActiveRecord::Base
  scope :published, where(:published => true)
end
</ruby>

就像之前的一样，这些方法也是可以串联的。

<ruby>
class Post < ActiveRecord::Base
  scope :publiced, where(:published => true).joins(:category)
end
</ruby>

scope 里面可以包含 scope ：

<ruby>
class Post < ActiveRecord::Base
  scope :published, where(:published => true)
  scope :published_and_commented, published.and(self.arel_table[:comments_count].gt(0))
end
</ruby>

我们可以在类里面调用 +published+ 这个 scope ：

<ruby>
Post.published # => [published posted]
</ruby>

我们也可以在一个包含 +Post+ 对象的 association 里面调用：

<ruby>
category = Category.first
category.posts.published # => [published posts belonging to this category]
</ruby>

h4. 和时间相关的

如果你在 scope 里面包含日期或者时间，你必需使用 lambda 来保证它们每次都重新计算。

<ruby>
class Post < ActiveRecord::Base
  scope :created_before_now, lambda { where("created_at < ?", Time.zone.now) }
end
</ruby>

如果不使用 +lambda+ ， +Time.zone.now+ 将只调用一次。

h4. 传递参数

当在 +scope+ 里面使用 +lambda+ 时，它可以带参数：

<ruby>
class Post < ActiveRecord::Base
  scope :created_before, lambda { |time| where("created_at < ?", time) }
end
</ruby>

它可以这样调用：

<ruby>
Post.created_before(Time.zone.now)
</ruby>

然而，这只是相当于实现了一个类方法的功能。

<ruby>
class Post < ActiveRecord::Base
  def self.created_before(time)
    where("created_at < ?", time)
  end
end
</ruby>

类方法是给 scope 传递参数的更好的方式。这些方法依然可以被 association 对象调用：

<ruby>
category.posts.created_before(time)
</ruby>

h4. 使用 scope

当你需要一个 relation 实例对象时， +scoped+ 方法就派上用场了。它会返回一个 +ActiveRecord::Relation+ 对象，并且这个对象可以继续调用其它 scope 。另外， association 也会用到 scope 。

<ruby>
client = Client.find_by_first_name("Ryan")
orders = client.orders.scoped
</ruby>

对于这些新的 +orders+ 对象，我们可以判定它可以继续调用更多的 scope 。比如说，如果我们希望在之后的调用点上返回最近 30 天的 order 记录。

<ruby>
orders.where("created_at > ?", 30.days.ago)
</ruby>



































































