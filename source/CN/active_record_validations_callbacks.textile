h2. Active Record 校验和回调

本章节将指导你如何hook into到Active Record的整个声明周期中。你将学习如何在数据保存到数据前对其进行验证，以及如何在Active Record对象生命周期的特定时刻进行定制化操作。

阅读完本章节并理解相关概念后，希望你能够：

* 理解Active Record对象的生命周期
* 使用Active Record内建的校验方法
* 定制自己的校验方法
* 和校验产生的错误信息打交道
* 创建回调函数来响应Active Record对象生命周期中的事件
* 创建特殊的类用来封装回调的共同行为 
* 创建观察者(Observers)来在原始类外相应声明周期中的事件

endprologue.

h3. 对象的生命周期

Rails应用通常的操作包括对象的创建，更新和销毁。Active Record提供了hooks into到<em>对象的声明周期</em>，所以我们可以更好地控制我们的应用和数据。

校验可以让我们确保只有有效数据被储存到数据中去。回调(Callbacks)和观察者(Observers)允许你在对象状态发生变化前后来触发特定逻辑代码。

h3. 校验的概述

在你接触到Rails应用中验证的过多细节之前，应该在整体上对验证有个了解。

h4. 为什么需要校验？

校验用来确保只有有效的数据可以被保存到数据库。例如，确保用户提供的电子邮件地址和住址的有效性对于你的应用来讲可能是非常重要的。

有很多方法用来在数据存入数据库之前进行校验，包括数据库约束，客户端校验，控制器()校验以及模型()校验。

* 数据库约束和/或存储过程的验证机制依赖于特定的数据库，导致测试和维护比较困难。但是，如果你的数据库需要提供给第三方应用，那么必要的数据库约束将是很好的策略。另外，数据库()验证能够安全地处理一些其他验证方法很难实现的情况(如在重负荷数据表中的唯一性约束)。
* 客户段校验很有用，但是如果单独使用的话通常来讲不是很可靠。如果是通过JavaScript来实现的校验，当用户在浏览器中关闭Javascript，校验就很容易被绕过。虽然如此，但如果结合其他的校验技术共同使用到你的网站，客户端校验将会非常方便，因为它可以立刻给用户反馈校验结果。
* 控制器()校验用起来很迷人，但是通常会使控制器变得笨重以至于难以测试和维护。所以无论何时， "keep your controllers skinny":http://weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model 都将是个好主意，他将让你的应用适合长期运行()。
* 模型()校验是最适合用来确保只有有效数据才可以被存入数据库的方法。它不依赖于特定数据库，也不能被客户端绕过，并且方便测试和维护。Rails提供了内建方法供常用的校验使用，并同时允许你创建自己的校验方法，这让验证变的很容易。

h4. 校验发生在什么时候？

Active Record对象有两种：一种表示数据库中的一行，另一种则不是。当你新创建了一个对象，如使用+new+方法，这时这个对象还不属于数据库。一旦你在这个对象上调用+call+方法，它将被保存到指定的数据库表中。Active Record使用+new_record?+这个实例方法来判断对象是否已经存入数据库。考虑下面这个简单的Active Record类：

<ruby>
class Person < ActiveRecord::Base
end
</ruby>

我们可一通过+rails console+的输出来查看它是如何工作的：

<ruby>
>> p = Person.new(:name => "John Doe")
=> #<Person id: nil, name: "John Doe", created_at: nil, :updated_at: nil>
>> p.new_record?
=> true
>> p.save
=> true
>> p.new_record?
=> false
</ruby>

创建和保存一个新对象将会在数据库中执行SQL +INSERT+命令。更新一个已经存在的记录将会在数据库中执行SQL +UPDATE+命令。校验通常在这些SQL命令执行前运行。如过有任何的校验失败，对象将被标记为无效，这样Active Record将不会执行+INSERT+或者+UPDATE+操作。帮助我们避免将无效数据保存到数据库中。你也可以选择在创建，保存或者更新时执行特定的校验。

注意：有很多方法去修改已经保存到数据库中的对象的状态。有些方法会触发校验，但是另一些方法并不会。这意味着如果我们不注意，仍然有可能将一个无效的对象保存到数据库中去的。

下列方法将会触发校验，并仅当对象通过校验后才会保存到数据库中：

* +create+
* +create!+
* +save+
* +save!+
* +update+
* +update_attributes+
* +update_attributes!+

带有感叹号的方法(如+save!+)将会在对象未通过校验时抛出异常。不带感叹号的方法不会抛出异常：+save+和+update+将会返回+false+，+create+和+update+将仅仅返回对象。

h4. 略过校验

下列方法将略过校验，无论对象是否有效，都将把对象保存到数据库中去。所以必须谨慎使用：

* +decrement!+
* +decrement_counter+
* +increment!+
* +increment_counter+
* +toggle!+
* +touch+
* +update_all+
* +update_attribute+
* +update_column+
* +update_counters+

需要注意的是，当将+:validate => false+作为参数传递给save方法时，+save+也可以略过校验。但也请谨慎使用这个技巧。

* +save(:validate => false)+

h4. +valid?+和+invalid?+

Rails使用+valid?+方法用来验证对象是否有效。所以你自己也可以使用此方法。+valid?+将会触发校验，当没有发现错误的时候返回true，否则返回false。

<ruby>
class Person < ActiveRecord::Base
  validates :name, :presence => true
end

Person.create(:name => "John Doe").valid? # => true
Person.create(:name => nil).valid? # => false
</ruby>

执行完校验后，所有发现的错误可以通过调用+errors+方法获取到，它将返回所有错误的集合。因此，运行完验证后如果这个错误集合为空，我们就可以认为这个对象是有效的。

需要注意的是通过+new+来实例化一个对象的过程不会检查到任何错误，即使这个对象确实是无效的。因为调用+new+方法并不会运行校验。

<ruby>
class Person < ActiveRecord::Base
  validates :name, :presence => true
end

>> p = Person.new
=> #<Person id: nil, name: nil>
>> p.errors
=> {}

>> p.valid?
=> false
>> p.errors
=> {:name=>["can't be blank"]}

>> p = Person.create
=> #<Person id: nil, name: nil>
>> p.errors
=> {:name=>["can't be blank"]}

>> p.save
=> false

>> p.save!
=> ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

>> Person.create!
=> ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
</ruby>

+invalid?+仅仅是+valid?+的反意词。+invlaid?+会触发校验，当检查到任何错误时返回true，否则返回false。

h4(#validations_overview-errors). +errors[]+

为了验证对象特定的属性是否有效，你可以使用+errors[:attribute]+。它将返回属性+:attribute+的所有错误。如果这个属性没有错误，将返回一个空数组。

这个方法只能在校验执行后使用，因为他只是检查并返回错误集合中的值，并不会自己触发校验。这不同与前面介绍的+ActiveRecord::Base+invalid?+方法，因为他不会验证对象作为一个整体时的有效性。它只是检查对于对象特定的属性是否检测到错误。

<ruby>
class Person < ActiveRecord::Base
  validates :name, :presence => true
end

>> Person.new.errors[:name].any? # => false
>> Person.create.errors[:name].any? # => true
</ruby>

在 "Working with Validation Errors":#working-with-validation-errors 章节中，我们将会对于校验错误讨论的更加深入一些。现在，就让我们来看看Rails默认提供的内建校验方法。

h3. Validation Helpers

Active Record offers many pre-defined validation helpers that you can use directly inside your class definitions. These helpers provide common validation rules. Every time a validation fails, an error message is added to the object's +errors+ collection, and this message is associated with the attribute being validated.
Active Record提够了很多预定义好的校验helper方法，你可以直接拿来使用到你的类声明中。这些helper方法提够了很多常用的校验规则。一旦有校验失败，和被校验的属性关联的一个错误信息将被添加到对象的+errors+集合中。

Each helper accepts an arbitrary number of attribute names, so with a single line of code you can add the same kind of validation to several attributes.
每个helper方法可以指定任意数量的属性名称，这意味着我们可以通过一行代码为多个属性添加同一类型的校验。

All of them accept the +:on+ and +:message+ options, which define when the validation should be run and what message should be added to the +errors+ collection if it fails, respectively. The +:on+ option takes one of the values +:save+ (the default), +:create+  or +:update+. There is a default error message for each one of the validation helpers. These messages are used when the +:message+ option isn't specified. Let's take a look at each one of the available helpers.
所有的helper方法都可以指定+:on+和+:message+选项，他们分别用来指定校验何时执行以及当校验失败时，何种错误信息应该被添加到+errors+集合中。+:on+的值必须为以下之一：+:save+(默认值)，+:create+，+：update+。而每个校验helper方法也有默认的错误信息。用在当+:message+没有指定时。现在让我们分别来看看提供的各个校验helper方法。

h4. +acceptance+

Validates that a checkbox on the user interface was checked when a form was submitted. This is typically used when the user needs to agree to your application's terms of service, confirm reading some text, or any similar concept. This validation is very specific to web applications and this 'acceptance' does not need to be recorded anywhere in your database (if you don't have a field for it, the helper will just create a virtual attribute).
用来验证当表单提交时，用户界面上的checkbox已经被选择。比较典型的使用场景是在使用你的应用前，需要确定客户已经阅读过并接受你的服务条款，或者其他相似的情况下。这种验证对于web应用来讲很特殊，这个被接受的状态并不一定需要保存到数据库中(如果我们没有在数据库表中建立这个字段，本helper方法将为它创建一个虚拟属性)。

<ruby>
class Person < ActiveRecord::Base
  validates :terms_of_service, :acceptance => true
end
</ruby>

The default error message for this helper is "_must be accepted_".
其默认的错误信息是"_must be accepted_"。

It can receive an +:accept+ option, which determines the value that will be considered acceptance. It defaults to "1" and can be easily changed.
该方法可以通过指定+:accept+选项来确定需要接受选项的值，"1"。

<ruby>
class Person < ActiveRecord::Base
  validates :terms_of_service, :acceptance => { :accept => 'yes' }
end
</ruby>

h4. +validates_associated+

You should use this helper when your model has associations with other models and they also need to be validated. When you try to save your object, +valid?+ will be called upon each one of the associated objects.
当你的model和其他的model有关联，并且需要校验被关联的model时，应该使用本helper方法。当你试图保存Active Record对象时，就将在所有关联的对象上执行+valid?+方法

<ruby>
class Library < ActiveRecord::Base
  has_many :books
  validates_associated :books
end
</ruby>

This validation will work with all of the association types.
本校验可以在所有的关联情况下执行。

CAUTION: Don't use +validates_associated+ on both ends of your associations. They would call each other in an infinite loop.
注意：不要在关联的两段同时使用+validates_associated+校验。因为这会导致他们相互调用而陷入死循环。

The default error message for +validates_associated+ is "_is invalid_". Note that each associated object will contain its own +errors+ collection; errors do not bubble up to the calling model.
本校验的默认错误信息为"_is invalid_"。需要注意的是每个关联的对象都含有其各自的+errors+集合；+errors+集合并不会绑定到执行此校验的对象上。

h4. +confirmation+

You should use this helper when you have two text fields that should receive exactly the same content. For example, you may want to confirm an email address or a password. This validation creates a virtual attribute whose name is the name of the field that has to be confirmed with "_confirmation" appended.
当你有两个文本框，并且需要接受同样的内容时，可以使用本helper方法。例如，你需要确认用户输入的电子邮件地址或者密码。这个helper方法会创建一个虚拟属性，名称为被确认字段名称后加"_confirmation"。

<ruby>
class Person < ActiveRecord::Base
  validates :email, :confirmation => true
end
</ruby>

In your view template you could use something like
在视图模板中使用如下

<erb>
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
</erb>

This check is performed only if +email_confirmation+ is not +nil+. To require confirmation, make sure to add a presence check for the confirmation attribute (we'll take a look at +presence+ later on this guide):
此验证只有当+email_confirmation+不为+nil+的时候才执行。所以确保次校验会执行，我们需要为confirmation属性添加presence校验(稍后我们会介绍presence校验)。

<ruby>
class Person < ActiveRecord::Base
  validates :email, :confirmation => true
  validates :email_confirmation, :presence => true
end
</ruby>

The default error message for this helper is "_doesn't match confirmation_".
本校验的错误信息默认为"_doesn't match confirmation_"。

h4. +exclusion+

This helper validates that the attributes' values are not included in a given set. In fact, this set can be any enumerable object.
本helper方法用来验证该属性的值没有包含在给定的结合中。实际上，这个集合可以是任意实现了enumerable接口的对象。

<ruby>
class Account < ActiveRecord::Base
  validates :subdomain, :exclusion => { :in => %w(www us ca jp),
    :message => "Subdomain %{value} is reserved." }
end
</ruby>

The +exclusion+ helper has an option +:in+ that receives the set of values that will not be accepted for the validated attributes. The +:in+ option has an alias called +:within+ that you can use for the same purpose, if you'd like to. This example uses the +:message+ option to show how you can include the attribute's value.
+exclusin+ 校验通过+:in+选项来指定一个集合，用来验证该属性的取值不再该集合中。+:in+选项有一个别名+:within+，你也可以使用。上面的例子使用+:message+选项来演示了你可以在错误信息中包含引用该属性的值。

The default error message is "_is reserved_".
本校验的默认错误信息为"_is reserved_"。

h4. +format+

This helper validates the attributes' values by testing whether they match a given regular expression, which is specified using the +:with+ option.
本方法用来校验该属性值是否匹配通过+:with+选项指定的正则表达式。

<ruby>
class Product < ActiveRecord::Base
  validates :legacy_code, :format => { :with => /\A[a-zA-Z]+\z/,
    :message => "Only letters allowed" }
end
</ruby>

The default error message is "_is invalid_".
本校验的默认错误信息为"_is invalid_"。

h4. +inclusion+

This helper validates that the attributes' values are included in a given set. In fact, this set can be any enumerable object.
本方法用来校验该属性的值包含在给定的集合中。实际上，该集合可以是任何实现了enumerable接口的对象。

<ruby>
class Coffee < ActiveRecord::Base
  validates :size, :inclusion => { :in => %w(small medium large),
    :message => "%{value} is not a valid size" }
end
</ruby>

The +inclusion+ helper has an option +:in+ that receives the set of values that will be accepted. The +:in+ option has an alias called +:within+ that you can use for the same purpose, if you'd like to. The previous example uses the +:message+ option to show how you can include the attribute's value.
+inclusion+校验通过+:in+选项来指定可接受值的集合。+:in+选项的别名为+:within+，同样可以使用。上面的例子演示了在错误信息中，你可以包含引用该属性的值。

The default error message for this helper is "_is not included in the list_".
该校验的默认错误信心为"_is not included in the list_"。

h4. +length+

This helper validates the length of the attributes' values. It provides a variety of options, so you can specify length constraints in different ways:
该校验用来检查属性值的长度。它提供了多种选项来指定长度约束条件

<ruby>
class Person < ActiveRecord::Base
  validates :name, :length => { :minimum => 2 }
  validates :bio, :length => { :maximum => 500 }
  validates :password, :length => { :in => 6..20 }
  validates :registration_number, :length => { :is => 6 }
end
</ruby>

The possible length constraint options are:
有以下几种约束选项：

* +:minimum+ - The attribute cannot have less than the specified length.
* +:minimum+ - 该属性值的长度不能小于指定的长度。
* +:maximum+ - The attribute cannot have more than the specified length.
* +:maximum+ - 该属性值的长度不能大于指定的长度.
* +:in+ (or +:within+) - The attribute length must be included in a given interval. The value for this option must be a range.
* +:in+ (or +:within+) - 该属性值的长度必须包含在指定的区间中。所以这个选项的值必须是range对象.
* +:is+ - The attribute length must be equal to the given value.
* +:is+ - 该属性值的长度必须等于制定的长度.

The default error messages depend on the type of length validation being performed. You can personalize these messages using the +:wrong_length+, +:too_long+, and +:too_short+ options and <tt>%{count}</tt> as a placeholder for the number corresponding to the length constraint being used. You can still use the +:message+ option to specify an error message.
默认错误信息依赖于所执行的长度验证的类型。你可以通过使用+:wrong_length+，+:too_long+，和 +:too_short+选项以及<tt>%{count}</tt> 作为所使用的相应长度约束的占位符来自由的订制信息。而且你人然可以使用+:message+选项来指定错误信息.

<ruby>
class Person < ActiveRecord::Base
  validates :bio, :length => { :maximum => 1000,
    :too_long => "%{count} characters is the maximum allowed" }
end
</ruby>

This helper counts characters by default, but you can split the value in a different way using the +:tokenizer+ option:
本校验默认是统计字母个数，但是你也可以通过指定+:tokenizer+选项来使用不同的方式分割属性值：


<ruby>
class Essay < ActiveRecord::Base
  validates :content, :length => {
    :minimum   => 300,
    :maximum   => 400,
    :tokenizer => lambda { |str| str.scan(/\w+/) },
    :too_short => "must have at least %{count} words",
    :too_long  => "must have at most %{count} words"
  }
end
</ruby>

Note that the default error messages are plural (e.g., "is too short (minimum is %{count} characters)"). For this reason, when +:minimum+ is 1 you should provide a personalized message or use +validates_presence_of+ instead. When +:in+ or +:within+ have a lower limit of 1, you should either provide a personalized message or call +presence+ prior to +length+.
需要注意的是默认错误信息为复数形式(如，"is too short (minimum is %{count} characters)")。因此，当+:minimum+为1的时候，你需要自己指定一个错误信息或者使用+validates_presence_of+来替换。当+:in+或+:within+下限为1时，你也需要指定一个错误信息或者使用+presence+来进行校验，而不是使用+length+。

The +size+ helper is an alias for +length+.
+size+校验是+length+校验的别名。

h4. +numericality+

This helper validates that your attributes have only numeric values. By default, it will match an optional sign followed by an integral or floating point number. To specify that only integral numbers are allowed set +:only_integer+ to true.
该校验用来检验属性值仅含有数字。默认会匹配整数和浮点数。可以通过设置+:only_integer+为true来使其之匹配整数。

If you set +:only_integer+ to +true+, then it will use the
如果你设置+:only_integer+为+true+，将使用如下的正则表达式来验证属性值。

<ruby>
/\A[<plus>-]?\d<plus>\Z/
</ruby>

regular expression to validate the attribute's value. Otherwise, it will try to convert the value to a number using +Float+.
否则，将会尝试将被校验的值先通过+Float+转换为副点数。

WARNING. Note that the regular expression above allows a trailing newline character.
警告：?

<ruby>
class Player < ActiveRecord::Base
  validates :points, :numericality => true
  validates :games_played, :numericality => { :only_integer => true }
end
</ruby>

Besides +:only_integer+, this helper also accepts the following options to add constraints to acceptable values:
除过+:only_integer+外，该校验也接受如下的选项来为被校验值添加额外的约束：

* +:greater_than+ - Specifies the value must be greater than the supplied value. The default error message for this option is "_must be greater than %{count}_".
* +:greater_than+ - 被验证属性值必须大于指定的值。该选项的默认错误信息为"_must be greater than %{count}_".
* +:greater_than_or_equal_to+ - Specifies the value must be greater than or equal to the supplied value. The default error message for this option is "_must be greater than or equal to %{count}_".
* +:greater_than_or_equal_to+ - 被验证属性值必须大于或等于指定的值。该选项的默认错误信息为"_must be greater than or equal to %{count}_".
* +:equal_to+ - Specifies the value must be equal to the supplied value. The default error message for this option is "_must be equal to %{count}_".
* +:equal_to+ - 被验证属性只必须等于指定的值。该选项的默认错误信息为"_must be equal to %{count}_".
* +:less_than+ - Specifies the value must be less than the supplied value. The default error message for this option is "_must be less than %{count}_".
* +:less_than+ - 被验证属性值必须小于指定的值。该选项的默认错误信息为"_must be less than %{count}_".
* +:less_than_or_equal_to+ - Specifies the value must be less than or equal the supplied value. The default error message for this option is "_must be less than or equal to %{count}_".
* +:less_than_or_equal_to+ - 被验证属性值必须小于或等于指定的值。该选项的默认错误信息为"_must be less than or equal to %{count}_".
* +:odd+ - Specifies the value must be an odd number if set to true. The default error message for this option is "_must be odd_".
* +:odd+ - 设置为true时，被验证属性值必须为奇数。该选项的默认错误信息为"_must be odd_".
* +:even+ - Specifies the value must be an even number if set to true. The default error message for this option is "_must be even_".
* +:even+ - 设置为true时，被验证属性值必须为偶数。该选项的默认错误信息为"_must be even_".

The default error message is "_is not a number_".
该校验的默认错误信息为"_is not a number_"。

h4. +presence+

This helper validates that the specified attributes are not empty. It uses the +blank?+ method to check if the value is either +nil+ or a blank string, that is, a string that is either empty or consists of whitespace.
该校验用来验证指定的属性不为空。其实它使用的是+blank?+方法来判断被校验值是否为+nil+或者是空字符串，即一个字符串为空或者只含有空格。

<ruby>
class Person < ActiveRecord::Base
  validates :name, :login, :email, :presence => true
end
</ruby>

If you want to be sure that an association is present, you'll need to test whether the foreign key used to map the association is present, and not the associated object itself.
如果你想确定对象之间的某一关联是否存在，应该通过检查关联的外键是否存在，而不是检查被关联对象自身。

<ruby>
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates :order_id, :presence => true
end
</ruby>

Since +false.blank?+ is true, if you want to validate the presence of a boolean field you should use <tt>validates :field_name, :inclusion => { :in => [true, false] }</tt>.
由于+false.blank?+为true，所以如果想校验一个boolean值是否存在，应该使用<tt>validates :field_name, :inclusion => { :in => [true, false] }</tt>。

The default error message is "_can't be empty_".
该校验的默认错误信息为"_can't be empty_"。

h4. +uniqueness+

This helper validates that the attribute's value is unique right before the object gets saved. It does not create a uniqueness constraint in the database, so it may happen that two different database connections create two records with the same value for a column that you intend to be unique. To avoid that, you must create a unique index in your database.
该校验用来检查在对象保存到数据库前，其指定的属性值是否唯一。但是该校验并不会在数据库上创建唯一性约束，所以有可能会出现不同的数据链接在你需要保持唯一性的列中插入了两个相同值。所以为了避免这样的情况，你必须为数据库建立一个惟一索引(?)。

<ruby>
class Account < ActiveRecord::Base
  validates :email, :uniqueness => true
end
</ruby>

The validation happens by performing an SQL query into the model's table, searching for an existing record with the same value in that attribute.
该校验实际上就是在model关联的数据表中执行一条使用被校验属性值的SQL查询语句(?)。

There is a +:scope+ option that you can use to specify other attributes that are used to limit the uniqueness check:
可以通过+:scope+选项来制定其他的属性来限制唯一性校验：

<ruby>
class Holiday < ActiveRecord::Base
  validates :name, :uniqueness => { :scope => :year,
    :message => "should happen once per year" }
end
</ruby>

There is also a +:case_sensitive+ option that you can use to define whether the uniqueness constraint will be case sensitive or not. This option defaults to true.
还可以通过+:case_sensitive+选项来指定唯一性约束是否是大小写敏感的，默认为true。

<ruby>
class Person < ActiveRecord::Base
  validates :name, :uniqueness => { :case_sensitive => false }
end
</ruby>

WARNING. Note that some databases are configured to perform case-insensitive searches anyway.
警告：需要注意的是某些数据库默认配置为在执行查询时总是大小写敏感的。

The default error message is "_has already been taken_".
该校验的默认错误信息为"_has already been taken_".

h4. +validates_with+

This helper passes the record to a separate class for validation.
这个helper会将记录传递到单独的类中校验。

<ruby>
class Person < ActiveRecord::Base
  validates_with GoodnessValidator
end

class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if record.first_name == "Evil"
      record.errors[:base] << "This person is evil"
    end
  end
end
</ruby>

NOTE: Errors added to +record.errors[:base]+ relate to the state of the record as a whole, and not to a specific attribute.
注意：错误信息是被添加到+record.errors[:base]+中，而不是某一特定的属性。

The +validates_with+ helper takes a class, or a list of classes to use for validation. There is no default error message for +validates_with+. You must manually add errors to the record's errors collection in the validator class.
+validates_with+ helper可以接受一个类或者一个类的数组用来校验。+validates_with+没有默认的错误信息，你必须自己在校验中添加适当的错误信息到Active Record对象的错误集合中。

To implement the validate method, you must have a +record+ parameter defined, which is the record to be validated.
声明validate方法时，参数列表中必须定义 +record+参数用来校验。

Like all other validations, +validates_with+ takes the +:if+, +:unless+ and +:on+ options. If you pass any other options, it will send those options to the validator class as +options+:
何其它的校验一样，+validates_with+接受+:if+, +:unless+和+:on+选项。如果你传入除此之外的选项，那么这些选项将作为+options+参数的一部分传递给校验器:

<ruby>
class Person < ActiveRecord::Base
  validates_with GoodnessValidator, :fields => [:first_name, :last_name]
end

class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if options[:fields].any?{|field| record.send(field) == "Evil" }
      record.errors[:base] << "This person is evil"
    end
  end
end
</ruby>

h4. +validates_each+

This helper validates attributes against a block. It doesn't have a predefined validation function. You should create one using a block, and every attribute passed to +validates_each+ will be tested against it. In the following example, we don't want names and surnames to begin with lower case.
该helper通过block来校验指定的属性。它没有预定义好的校验方法。你必须通过block来自己创建相应的校验逻辑，每个被传递给+validates_each+的属性都将被依次校验。如下例中，我们需要确保name和surname不是以小写字母开头的。

<ruby>
class Person < ActiveRecord::Base
  validates_each :name, :surname do |record, attr, value|
    record.errors.add(attr, 'must start with upper case') if value =~ /\A[a-z]/
  end
end
</ruby>

The block receives the record, the attribute's name and the attribute's value. You can do anything you like to check for valid data within the block. If your validation fails, you should add an error message to the model, therefore making it invalid.
block接受record对象，属性名称和属性值三个参数。你可以在block中实现任何的校验逻辑。如果校验失败，你需要添加错误信息到Active Record对象中，这会将该对象标记为无效的。

h3. Common Validation Options
h3. 常用校验选项 

These are common validation options:
这里有意些常用的校验选项：

h4. +:allow_nil+

The +:allow_nil+ option skips the validation when the value being validated is +nil+.
+:allow_nil+可以在被校验属性值为+nil+的时候跳过校验。

<ruby>
class Coffee < ActiveRecord::Base
  validates :size, :inclusion => { :in => %w(small medium large),
    :message => "%{value} is not a valid size" }, :allow_nil => true
end
</ruby>

TIP: +:allow_nil+ is ignored by the presence validator.
TIP: +:allow_nil+选项在presence校验中将被忽略。

h4. +:allow_blank+

The +:allow_blank+ option is similar to the +:allow_nil+ option. This option will let validation pass if the attribute's value is +blank?+, like +nil+ or an empty string for example.
+:allow_blank+选项和+:allow_nil+选项很相似。当被校验的值为+blank?+时，譬如+nil+或者空字符串，校验将被跳过。

<ruby>
class Topic < ActiveRecord::Base
  validates :title, :length => { :is => 5 }, :allow_blank => true
end

Topic.create("title" => "").valid?  # => true
Topic.create("title" => nil).valid? # => true
</ruby>

TIP: +:allow_blank+ is ignored by the presence validator.
TIP: +:allow_blank+选项在presence校验中将被忽略。

h4. +:message+

As you've already seen, the +:message+ option lets you specify the message that will be added to the +errors+ collection when validation fails. When this option is not used, Active Record will use the respective default error message for each validation helper.
如你所见，你可以通过+:message+选项来指定当校验失败时需要添加到+errors+集合中的错误信息。如果没有使用该选项，Active Record将会使用校验helper各自默认的错误信息。

h4. +:on+

The +:on+ option lets you specify when the validation should happen. The default behavior for all the built-in validation helpers is to be run on save (both when you're creating a new record and when you're updating it). If you want to change it, you can use +:on => :create+ to run the validation only when a new record is created or +:on => :update+ to run the validation only when a record is updated.
你可以通过+:on+选项来指定何时进行校验。所有内建的校验helpers默认在Active Record对象save的时候运行校验(即无论你是新建一个AR对象还是更新它都会执行校验)。如果你想改变校验时机，你可以使用+:on => :create+来指定仅在新建一个Active Record对象的时候进行校验，或者使用+:on => :update+来指定尽在更新一个Active Record对象的时候进行校验。

<ruby>
class Person < ActiveRecord::Base
  # it will be possible to update email with a duplicated value
  validates :email, :uniqueness => true, :on => :create

  # it will be possible to create the record with a non-numerical age
  validates :age, :numericality => true, :on => :update

  # the default (validates on both create and update)
  validates :name, :presence => true, :on => :save
end
</ruby>

h3. Strict Validations
h3. 严格校验

You can also specify validations to be strict and raise +ActiveModel::StrictValidationFailed+ when the object is invalid.
你也可以制定校验为严格，这样当AR对象校验失败是会抛出+ActiveModel::StrictValidationFailed+异常。

<ruby>
class Person < ActiveRecord::Base
  validates :name, :presence => { :strict => true }
end

Person.new.valid?  => ActiveModel::StrictValidationFailed: Name can't be blank
</ruby>

h3. Conditional Validation
h3. 有条件的校验 

Sometimes it will make sense to validate an object just when a given predicate is satisfied. You can do that by using the +:if+ and +:unless+ options, which can take a symbol, a string, a +Proc+ or an +Array+. You may use the +:if+ option when you want to specify when the validation *should* happen. If you want to specify when the validation *should not* happen, then you may use the +:unless+ option.
有时只有当满足给定的条件后在对AR对象进行校验是非常必要的。你可以使用+:if+和+:unless+选项来达到这个目的，他们接受一个符号，字符串，+Porc+或者一个+Array+。使用+:if+来指定何时应该执行校验，使用+unless+来指定何时不应该执行校验。

h4. Using a Symbol with +:if+ and +:unless+
h4. Symbol配合+:if+和+:unless+

You can associate the +:if+ and +:unless+ options with a symbol corresponding to the name of a method that will get called right before validation happens. This is the most commonly used option.
你可以通过symbol来指定一个在校验前执行的一个方法的名字，这是最常用的方法。

<ruby>
class Order < ActiveRecord::Base
  validates :card_number, :presence => true, :if => :paid_with_card?

  def paid_with_card?
    payment_type == "card"
  end
end
</ruby>

h4. Using a String with +:if+ and +:unless+

You can also use a string that will be evaluated using +eval+ and needs to contain valid Ruby code. You should use this option only when the string represents a really short condition.
你也可以使用字符串制定一段有效的Ruby代码，将通过eval来执行。仅当条件很短的时候建议使用此方式。

<ruby>
class Person < ActiveRecord::Base
  validates :surname, :presence => true, :if => "name.nil?"
end
</ruby>

h4. Using a Proc with +:if+ and +:unless+

Finally, it's possible to associate +:if+ and +:unless+ with a +Proc+ object which will be called. Using a +Proc+ object gives you the ability to write an inline condition instead of a separate method. This option is best suited for one-liners.
最后，可以制定一个Proc对象。+Proc+对象可以让你使用inline条件，而不用单独些一个方法。这种方式最适合一行代码。

<ruby>
class Account < ActiveRecord::Base
  validates :password, :confirmation => true,
    :unless => Proc.new { |a| a.password.blank? }
end
</ruby>

h4. Grouping conditional validations

Sometimes it is useful to have multiple validations use one condition, it can be easily achieved using +with_options+.
有时多个校验以同一个条件为前提很有用，可以通过+with_options+轻松达到次目的。

<ruby>
class User < ActiveRecord::Base
  with_options :if => :is_admin? do |admin|
    admin.validates :password, :length => { :minimum => 10 }
    admin.validates :email, :presence => true
  end
end
</ruby>

All validations inside of +with_options+ block will have automatically passed the condition +:if => :is_admin?+
所有在+with_options+块中的校验将自动添加条件+:if => :is_admin?+

h4. Combining validation conditions
h4. 组合校验条件

On the other hand, when multiple conditions define whether or not a validation should happen, an +Array+ can be used. Moreover, you can apply both +:if:+ and +:unless+ to the same validation.
另一方面，当多个条件被用来指定是否需要执行校验，+Array+对象可以派上用场。而且，你还可一在同一个校验中同时使用+:if+和+：unless+来制定条件。

<ruby>
class Computer < ActiveRecord::Base
  validates :mouse, :presence => true,
                    :if => ["market.retail?", :desktop?]
                    :unless => Proc.new { |c| c.trackpad.present? }
end
</ruby>

The validation only runs when all the +:if+ conditions and none of the +:unless+ conditions are evaluated to +true+.
校验只用在所有的+:if+指定的条件全部评估为+true+，并且所有+:unless+指定的条件没有任何一个评估为+true+的时候才能执行。

h3. Performing Custom Validations
h3. 自定义校验

When the built-in validation helpers are not enough for your needs, you can write your own validators or validation methods as you prefer.
当内建的校验helpers不能满足你的需求时，你可以根据自己的需求来编写自己的校验器或者校验函数。

h4. Custom Validators
h4. 自定义校验器

Custom validators are classes that extend <tt>ActiveModel::Validator</tt>. These classes must implement a +validate+ method which takes a record as an argument and performs the validation on it. The custom validator is called using the +validates_with+ method.
自定义校验器其实就是继承自<tt>ActiveModel::Validator</tt>的类。该类中必须实现一个+validate+方法，它需要接受一个AR对象作为参数。自定义校验器通过+validates_with+来调用。

<ruby>
class MyValidator < ActiveModel::Validator
  def validate(record)
    unless record.name.starts_with? 'X'
      record.errors[:name] << 'Need a name starting with X please!'
    end
  end
end

class Person
  include ActiveModel::Validations
  validates_with MyValidator
end
</ruby>

The easiest way to add custom validators for validating individual attributes is with the convenient <tt>ActiveModel::EachValidator</tt>. In this case, the custom validator class must implement a +validate_each+ method which takes three arguments: record, attribute and value which correspond to the instance, the attribute to be validated and the value of the attribute in the passed instance.
而为需要校验的单独属性添加自定义校验最便捷的方法是使用<tt>ActiveModel::EachCalidator</tt>。这种情况下，自定义校验类必须实现一个+validate_each+方法，它接受三个参数：record，attribute和value，它们分别代表AR对象实例，被校验的属性和被校验属性的值。

<ruby>
class EmailValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless value =~ /\A([^@\s]<plus>)@((?:[-a-z0-9]<plus>\.)+[a-z]{2,})\z/i
      record.errors[attribute] << (options[:message] || "is not an email")
    end
  end
end

class Person < ActiveRecord::Base
  validates :email, :presence => true, :email => true
end
</ruby>

As shown in the example, you can also combine standard validations with your own custom validators.
如上例所示，你可以将标准内建校验helpers和自定义校验组合一起使用。

h4. Custom Methods
h4. 自定义方法

You can also create methods that verify the state of your models and add messages to the +errors+ collection when they are invalid. You must then register these methods by using the +validate+ class method, passing in the symbols for the validation methods' names.
你也可以通过创建自定义方法来验证models的状态，并且当对象校验失败无效后添加相应的信息到+errors+对象。你必须使用+validate+类方法，通过symbols传入校验方法的方法名来注册自定义校验方法。

You can pass more than one symbol for each class method and the respective validations will be run in the same order as they were registered.
你可以传入多个自定义校验的方法名，他们将按照注册顺于依次执行校验。

<ruby>
class Invoice < ActiveRecord::Base
  validate :expiration_date_cannot_be_in_the_past,
    :discount_cannot_be_greater_than_total_value

  def expiration_date_cannot_be_in_the_past
    if !expiration_date.blank? and expiration_date < Date.today
      errors.add(:expiration_date, "can't be in the past")
    end
  end

  def discount_cannot_be_greater_than_total_value
    if discount > total_value
      errors.add(:discount, "can't be greater than total value")
    end
  end
end
</ruby>

By default such validations will run every time you call +valid?+. It is also possible to control when to run these custom validations by giving an +:on+ option to the +validate+ method, with either: +:create+ or +:update+.
默认情况下，当你调用+valid?+时，这些校验总会执行。但可以通过+:on+选项制定+:create+或+:update+来控制何时执行校验。

<ruby>
class Invoice < ActiveRecord::Base
  validate :active_customer, :on => :create

  def active_customer
    errors.add(:customer_id, "is not active") unless customer.active?
  end
end
</ruby>

You can even create your own validation helpers and reuse them in several different models. For example, an application that manages surveys may find it useful to express that a certain field corresponds to a set of choices:
你可以创建自己的校验helpers，并且在多个models中复用。例如，一个管理调查问卷的应用会发现它很有用，指定特定字段的取值范围应该限定到特定的集合中：

<ruby>
ActiveRecord::Base.class_eval do
  def self.validates_as_choice(attr_name, n, options={})
    validates attr_name, :inclusion => { { :in => 1..n }.merge!(options) }
  end
end
</ruby>

Simply reopen +ActiveRecord::Base+ and define a class method like that. You'd typically put this code somewhere in +config/initializers+. You can use this helper like this:
只是简单的打开+ActiveRecord::Base+类并如上定义了一个类方法。通常你应该将这些代码放到+config/initializers+文件夹中。你可以如下使用它了：

<ruby>
class Movie < ActiveRecord::Base
  validates_as_choice :rating, 5
end
</ruby>

h3. Working with Validation Errors
h3. 校验错误信息的使用 

In addition to the +valid?+ and +invalid?+ methods covered earlier, Rails provides a number of methods for working with the +errors+ collection and inquiring about the validity of objects.
作为前面提到过的+valid?+和+invalid?+的补充，Rails提供了一些方法来配合+errors+集合使用以及检查对象的有效性。

The following is a list of the most commonly used methods. Please refer to the +ActiveModel::Errors+ documentation for a list of all the available methods.
下面是最常用的一些方法。你也可以通过+ActiveModel::Errors+文档来查看所有有效的方法。

h4(#working_with_validation_errors-errors). +errors+

Returns an instance of the class +ActiveModel::Errors+ containing all errors. Each key is the attribute name and the value is an array of strings with all errors.
返回一个包含所有错误信息的+ActiveModel::Errors+实例变量。每个键值为属性名称，值为该属性对应错误信息组成的字符串数组。

<ruby>
class Person < ActiveRecord::Base
  validates :name, :presence => true, :length => { :minimum => 3 }
end

person = Person.new
person.valid? # => false
person.errors
 # => {:name => ["can't be blank", "is too short (minimum is 3 characters)"]}

person = Person.new(:name => "John Doe")
person.valid? # => true
person.errors # => []
</ruby>

h4(#working_with_validation_errors-errors-2). +errors[]+

+errors[]+ is used when you want to check the error messages for a specific attribute. It returns an array of strings with all error messages for the given attribute, each string with one error message. If there are no errors related to the attribute, it returns an empty array.
使用+errors[]+可以产看特定属性的错误信息。它会返回一个包含了该属性对应的所有错误信息组成的字符串数组，每句是一个条错误信息。如果该属性没有想对应的错误信息，将返回一个空数组。

<ruby>
class Person < ActiveRecord::Base
  validates :name, :presence => true, :length => { :minimum => 3 }
end

person = Person.new(:name => "John Doe")
person.valid? # => true
person.errors[:name] # => []

person = Person.new(:name => "JD")
person.valid? # => false
person.errors[:name] # => ["is too short (minimum is 3 characters)"]

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
</ruby>

h4. +errors.add+

The +add+ method lets you manually add messages that are related to particular attributes. You can use the +errors.full_messages+ or +errors.to_a+ methods to view the messages in the form they might be displayed to a user. Those particular messages get the attribute name prepended (and capitalized). +add+ receives the name of the attribute you want to add the message to, and the message itself.
通过+add+方法可以手动为特定的属性添加相关的错误信息。你可以使用+errors.full_messages+或者+errors.to_a+方法将错误信息展示在用户的表单上。这些特定的错误信息添加了属性(首字母大写)名称作为前缀。+add+方法需要你想添加错误信息的属性名称以及错误信息内容两个参数。

<ruby>
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors.add(:name, "cannot contain the characters !@#%*()_-+=")
  end
end

person = Person.create(:name => "!@#")

person.errors[:name]
 # => ["cannot contain the characters !@#%*()_-+="]

person.errors.full_messages
 # => ["Name cannot contain the characters !@#%*()_-+="]
</ruby>

Another way to do this is using +[]=+ setter
也可以使用+[]=+达到同样的目的

<ruby>
  class Person < ActiveRecord::Base
    def a_method_used_for_validation_purposes
      errors[:name] = "cannot contain the characters !@#%*()_-+="
    end
  end

  person = Person.create(:name => "!@#")

  person.errors[:name]
   # => ["cannot contain the characters !@#%*()_-+="]

  person.errors.to_a
   # => ["Name cannot contain the characters !@#%*()_-+="]
</ruby>

h4. +errors[:base]+

You can add error messages that are related to the object's state as a whole, instead of being related to a specific attribute. You can use this method when you want to say that the object is invalid, no matter the values of its attributes. Since +errors[:base]+ is an array, you can simply add a string to it and it will be used as an error message.
你也可以将添加的错误信息关联到对象自身整体，而不是特定的某一属性。当你想要表示该对象为无效的，无论它所包含的属性值如何时，可以使用该方法。因为+errors[:base]+是一个数组，我们将错误信息直接添加进这个数组就可以了，

<ruby>
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors[:base] << "This person is invalid because ..."
  end
end
</ruby>

h4. +errors.clear+

The +clear+ method is used when you intentionally want to clear all the messages in the +errors+ collection. Of course, calling +errors.clear+ upon an invalid object won't actually make it valid: the +errors+ collection will now be empty, but the next time you call +valid?+ or any method that tries to save this object to the database, the validations will run again. If any of the validations fail, the +errors+ collection will be filled again.
当你想要删除+errors+集合中的所有错误信息时，可以使用+clear+方法。当然，在一个校验后无效的对象上调用+errors.clear+方法并不能使其变为有效：虽然+errors+集合在调用玩该方法后为空，但是下次你条用+valid?+或者其他方法试图将该对象保存到数据库的方法时，校验会再执行一次。当任何校验失败时，错误信息就又会被添加入+errors+集合中。

<ruby>
class Person < ActiveRecord::Base
  validates :name, :presence => true, :length => { :minimum => 3 }
end

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]

person.errors.clear
person.errors.empty? # => true

p.save # => false

p.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
</ruby>

h4. +errors.size+

The +size+ method returns the total number of error messages for the object.
+size+方法可以返回被校验对象的错误信息总数。

<ruby>
class Person < ActiveRecord::Base
  validates :name, :presence => true, :length => { :minimum => 3 }
end

person = Person.new
person.valid? # => false
person.errors.size # => 2

person = Person.new(:name => "Andrea", :email => "andrea@example.com")
person.valid? # => true
person.errors.size # => 0
</ruby>

h3. Displaying Validation Errors in the View
h3. 在View中展示校验错误信息 

"DynamicForm":https://github.com/joelmoss/dynamic_form provides helpers to display the error messages of your models in your view templates.
"DynamicForm":https://github.com/joelmoss/dynamic_form 提供了一些helpers可以帮助我们在视图的模板中显示错误信息。

You can install it as a gem by adding this line to your Gemfile:
你可以通过在Gemfile文件中添加下列代码来安装该gem包：

<ruby>
gem "dynamic_form"
</ruby>

Now you will have access to the two helper methods +error_messages+ and +error_messages_for+ in your view templates.
现在你就可以在试图模板中访问+error_messages+和+error_messages_for+两个helper方法了。

h4. +error_messages+ and +error_messages_for+
h4. +error_messages+和+error_messages_for+

When creating a form with the +form_for+ helper, you can use the +error_messages+ method on the form builder to render all failed validation messages for the current model instance.
当使用+form_for+ helper来创建表单的时候，你可以使用+error_messages+方法在在表单上显示当前模型实力的所有校验信息。

<ruby>
class Product < ActiveRecord::Base
  validates :description, :value, :presence => true
  validates :value, :numericality => true, :allow_nil => true
end
</ruby>

<erb>
<%= form_for(@product) do |f| %>
  <%= f.error_messages %>
  <p>
    <%= f.label :description %><br />
    <%= f.text_field :description %>
  </p>
  <p>
    <%= f.label :value %><br />
    <%= f.text_field :value %>
  </p>
  <p>
    <%= f.submit "Create" %>
  </p>
<% end %>
</erb>

If you submit the form with empty fields, the result will be similar to the one shown below:
如果你提交了一个空表单，结果会如下图显示的一样：

!images/error_messages.png(Error messages)!

NOTE: The appearance of the generated HTML will be different from the one shown, unless you have used scaffolding. See "Customizing the Error Messages CSS":#customizing-error-messages-css.
注意：产生的HTML可能会和上面显示的不太一样，除非你已经使用了脚手架来生成代码。参考 "Customizing the Error Messages CSS":#customizing-error-messages-css.

You can also use the +error_messages_for+ helper to display the error messages of a model assigned to a view template. It is very similar to the previous example and will achieve exactly the same result.
你同样可以使用+error_messages_for+ helper来在视图模板中显示和模型相关的错误信息。如下面的例子，我们可以获得和前面例子几乎相同的效果。

<erb>
<%= error_messages_for :product %>
</erb>

The displayed text for each error message will always be formed by the capitalized name of the attribute that holds the error, followed by the error message itself.
显示出的错误信息总是以首字母大写的属性名为前缀，而后接着才错误信息本身的内容内容。

Both the +form.error_messages+ and the +error_messages_for+ helpers accept options that let you customize the +div+ element that holds the messages, change the header text, change the message below the header, and specify the tag used for the header element. For example,
+form.error_messages+和+error_messages_for+方法都可以接受参数以定制用来显示错误信息的+div+元素，改变header的文字，让具体的错误信息显示在header下面，我们甚至可以制定header元素使用的HTML标签。例如：

<erb>
<%= f.error_messages :header_message => "Invalid product!",
  :message => "You'll need to fix the following fields:",
  :header_tag => :h3 %>
</erb>

results in:
结果如下：

!images/customized_error_messages.png(Customized error messages)!

If you pass +nil+ in any of these options, the corresponding section of the +div+ will be discarded.
但是如果我们给这些选项中的任意一个传递了+nil+，用来显示错误信息的+div+ HTML片段都将不显示(?)。

h4(#customizing-error-messages-css). Customizing the Error Messages CSS
h4(#customizing-error-messages-css). 定制错误信息的 CSS

The selectors used to customize the style of error messages are:
用来定制错误信息样式的CSS选择器有一下几种：

* +.field_with_errors+ - Style for the form fields and labels with errors.
* +.field_with_errors+ - 表单中错误字段和标签的样式。
* +#error_explanation+ - Style for the +div+ element with the error messages.
* +#error_explanation+ - +div+元素中的具体错误信息的样式。
* +#error_explanation h2+ - Style for the header of the +div+ element.
* +#error_explanation h2+ - +div+元素的标题样式。
* +#error_explanation p+ - Style for the paragraph holding the message that appears right below the header of the +div+ element.
* +#error_explanation p+ - Style for the paragraph holding the message that appears right below the header of the +div+ element.+div+元素中标题下面防止具体错误信息段落的样式。
* +#error_explanation ul li+ - Style for the list items with individual error messages.
* +#error_explanation ul li+ - 各自错误信息对应的列表元素的样式。

If scaffolding was used, file +app/assets/stylesheets/scaffolds.css.scss+ will have been generated automatically. This file defines the red-based styles you saw in the examples above.
如果使用了scaffolding，将会自动生成文件 +app/assets/stylesheets/scaffolds.css.scss+ ，用来定义如上图中所示的红色风格的样式。

The name of the class and the id can be changed with the +:class+ and +:id+ options, accepted by both helpers.
class和id的名称可以通过使用+:class+和+:id+选项来进行设置。

h4. Customizing the Error Messages HTML
h4. 自定义错误信息的HTML

The way form fields with errors are treated is defined by +ActionView::Base.field_error_proc+. This is a +Proc+ that receives two parameters:
错误字段是通过+ActionView::Base.field_error_proc+来定义的。这是一个接受来那个参数的+Proc+:

* A string with the HTML tag
* 一段定义HTML标签字符串。
* A instance of +ActionView::Helpers::InstanceTag+.
* 一个 +ActionView::Helpers::InstanceTag+实例。

Below is a simple example where we change the Rails behavior to always display the error messages in front of each of the form fields in error. The error messages will be enclosed by a +span+ element with a +validation-error+ CSS class. There will be no +div+ element enclosing the +input+ element, so we get rid of that red border around the text field. You can use the +validation-error+ CSS class to style it anyway you want.
下面是一个简单的示例，我们通过改变Rails的默认行为，让错误信息显示在各错误字段前面。错误信息包装在一个+validation-error+CSS类的+span+元素中。这里+input+元素不会包装在+div+元素中，这样我们就摆脱了文本字段被红色边框围绕的烦恼。你还可以在CSS中通过+validation-error+来进一步定义你想要的样式。

<ruby>
ActionView::Base.field_error_proc = Proc.new do |html_tag, instance|
  errors = Array(instance.error_message).join(',')
  %(#{html_tag}<span class="validation-error">&nbsp;#{errors}</span>).html_safe
end
</ruby>

The result looks like the following:
结果如下：

!images/validation_error_messages.png(Validation error messages)!

h3. Callbacks Overview
h3. 回调简介 

Callbacks are methods that get called at certain moments of an object's life cycle. With callbacks it is possible to write code that will run whenever an Active Record object is created, saved, updated, deleted, validated, or loaded from the database.
回调就是会在对象特定生命周期调用的方法。通过回调，我们可以控制代码让他们运行在Active Record对象创建，保存，更新，删除，校验或者从数据库载入时。

h4. Callback Registration
h4. 回调注册 

In order to use the available callbacks, you need to register them. You can implement the callbacks as ordinary methods and use a macro-style class method to register them as callbacks:
使用回调前，你必须先要注册他们。你可像平常一样声明一个方法，然后使用macro-style类方法注册他们为回调：

<ruby>
class User < ActiveRecord::Base
  validates :login, :email, :presence => true

  before_validation :ensure_login_has_a_value

  protected
  def ensure_login_has_a_value
    if login.nil?
      self.login = email unless email.blank?
    end
  end
end
</ruby>

The macro-style class methods can also receive a block. Consider using this style if the code inside your block is so short that it fits in a single line:
而macro-style类方法也可以接受block。当block中的代码比较少的时候，可以考虑使用这种形式：

<ruby>
class User < ActiveRecord::Base
  validates :login, :email, :presence => true

  before_create do |user|
    user.name = user.login.capitalize if user.name.blank?
  end
end
</ruby>

It is considered good practice to declare callback methods as protected or private. If left public, they can be called from outside of the model and violate the principle of object encapsulation.
一般认为将回调方法生命为protected或者private是比较好的实践。而一旦我们生命为public时，该方法就可以直接在模型外调用，这破坏了对象封装的原则。

h3. Available Callbacks
h3. 有效的回调

Here is a list with all the available Active Record callbacks, listed in the same order in which they will get called during the respective operations:
下面列除了Acrive Record中有效的回调，...

h4. Creating an Object
h4. 创建对象时

* +before_validation+
* +after_validation+
* +before_save+
* +around_save+
* +before_create+
* +around_create+
* +after_create+
* +after_save+

h4. Updating an Object
h4. 更新对象时 

* +before_validation+
* +after_validation+
* +before_save+
* +around_save+
* +before_update+
* +around_update+
* +after_update+
* +after_save+

h4. Destroying an Object
h4. 销毁对象时

* +before_destroy+
* +around_destroy+
* +after_destroy+

WARNING. +after_save+ runs both on create and update, but always _after_ the more specific callbacks +after_create+ and +after_update+, no matter the order in which the macro calls were executed.
警告。+after_save+ 在创建和更新对象是都会运行，...

h4. +after_initialize+ and +after_find+
h4. +after_initialize+ 和 +after_find+

The +after_initialize+ callback will be called whenever an Active Record object is instantiated, either by directly using +new+ or when a record is loaded from the database. It can be useful to avoid the need to directly override your Active Record +initialize+ method.
+after_initialize+ 在Active Record对象被实例化时调用，无论是通过+new+ 来新建一个对象还是从数据库中载入一个对象，这非常游泳，因为可以避免你直接重写你Active Record的+initialize+方法。

The +after_find+ callback will be called whenever Active Record loads a record from the database. +after_find+ is called before +after_initialize+ if both are defined.
+after_find+ 在通过数据库载入Active Record对象是别调用。当+after_find+和+after_initialize+同时注册时，+after_find+将首先被调用。

The +after_initialize+ and +after_find+ callbacks have no +before_*+ counterparts, but they can be registered just like the other Active Record callbacks.
+after_initialize+和 +after_find+回调没有与之对用的+before_*+回调，但是他们可以和其他Active Record回调一样注册使用。

<ruby>
class User < ActiveRecord::Base
  after_initialize do |user|
    puts "You have initialized an object!"
  end

  after_find do |user|
    puts "You have found an object!"
  end
end

>> User.new
You have initialized an object!
=> #<User id: nil>

>> User.first
You have found an object!
You have initialized an object!
=> #<User id: 1>
</ruby>

h3. Running Callbacks
h3. 执行回调 

The following methods trigger callbacks:
下面的方法会触发回调：

* +create+
* +create!+
* +decrement!+
* +destroy+
* +destroy_all+
* +increment!+
* +save+
* +save!+
* +save(:validate => false)+
* +toggle!+
* +update+
* +update_attribute+
* +update_attributes+
* +update_attributes!+
* +valid?+

Additionally, the +after_find+ callback is triggered by the following finder methods:
另外，+after_find+回调只会被下面列出的方法触发：

* +all+
* +first+
* +find+
* +find_all_by_<em>attribute</em>+
* +find_by_<em>attribute</em>+
* +find_by_<em>attribute</em>!+
* +last+

The +after_initialize+ callback is triggered every time a new object of the class is initialized.
而+after_initialize+回调在每次新AR对象初始化时都会被触发。

h3. Skipping Callbacks
h3. 跳过回调 

Just as with validations, it is also possible to skip callbacks. These methods should be used with caution, however, because important business rules and application logic may be kept in callbacks. Bypassing them without understanding the potential implications may lead to invalid data.
和校验相同，我们也可以跳过回调。但是这些方法使用是必须多加注意，因为重要的业务逻辑可能会放在回调中。在没有完全理解其潜在危险的情况下贸然使用可能会导致无效数据的额产生。

* +decrement+
* +decrement_counter+
* +delete+
* +delete_all+
* +find_by_sql+
* +increment+
* +increment_counter+
* +toggle+
* +touch+
* +update_column+
* +update_all+
* +update_counters+

h3. Halting Execution
h3. 执行挂起

As you start registering new callbacks for your models, they will be queued for execution. This queue will include all your model's validations, the registered callbacks, and the database operation to be executed.
当你为模型注册回调时，他们将会被放入队列中执行。这个队列中将包括模型所有的校验，所有注册的回调，以及对数据库的操作。

The whole callback chain is wrapped in a transaction. If any <em>before</em> callback method returns exactly +false+ or raises an exception, the execution chain gets halted and a ROLLBACK is issued; <em>after</em> callbacks can only accomplish that by raising an exception.
整个回调链包装在一个事务中。如果任何一个<em>before</em>回调方法返回+false+或者抛出一场，整个执行链会中止并且运行ROLLBACK；<em>after</em>回调则只会抛出一个异常。

WARNING. Raising an arbitrary exception may break code that expects +save+ and its friends not to fail like that. The +ActiveRecord::Rollback+ exception is thought precisely to tell Active Record a rollback is going on. That one is internally captured but not reraised.
警告。...

h3. Relational Callbacks
h3. 关联回调 

Callbacks work through model relationships, and can even be defined by them. Suppose an example where a user has many posts. A user's posts should be destroyed if the user is destroyed. Let's add an +after_destroy+ callback to the +User+ model by way of its relationship to the +Post+ model:
...

<ruby>
class User < ActiveRecord::Base
  has_many :posts, :dependent => :destroy
end

class Post < ActiveRecord::Base
  after_destroy :log_destroy_action

  def log_destroy_action
    puts 'Post destroyed'
  end
end

>> user = User.first
=> #<User id: 1>
>> user.posts.create!
=> #<Post id: 1, user_id: 1>
>> user.destroy
Post destroyed
=> #<User id: 1>
</ruby>

h3. Conditional Callbacks
h3. 条件回调 

As with validations, we can also make the calling of a callback method conditional on the satisfaction of a given predicate. We can do this using the +:if+ and +:unless+ options, which can take a symbol, a string, a +Proc+ or an +Array+. You may use the +:if+ option when you want to specify under which conditions the callback *should* be called. If you want to specify the conditions under which the callback *should not* be called, then you may use the +:unless+ option.
和校验相同，我们也可以让只用当满足特定的条件时才会出发回调。我们可以使用+:if+和+:unless+选项，可以接受一个符号(symbol)，字符串，+Proc+或者+Array+。使用+:if+选项来指定在什么条件下回调应该被触发。而当你想指定在何种情况下回调不应该触发时，请使用+:unless+选项。

h4. Using +:if+ and +:unless+ with a +Symbol+
h4. 使用+:Symbol+作为+:if+和+:unless+的参数

You can associate the +:if+ and +:unless+ options with a symbol corresponding to the name of a predicate method that will get called right before the callback. When using the +:if+ option, the callback won't be executed if the predicate method returns false; when using the +:unless+ option, the callback won't be executed if the predicate method returns true. This is the most common option. Using this form of registration it is also possible to register several different predicates that should be called to check if the callback should be executed.
你可传递给一个symbol作为+:if+和+:unless+选项的参数，该symbol表示一个谓词方法的名称，该方法在回调发生前调用。当时用+:if+选项时，如果该方法返回false，回调就不会触发；而当使用+:unless+选项时，如果该方法返回true，回调就不会被触发。这是最常用的选项。使用这样的方式，我们可以注册多个不同的谓词方法来确定回调是否应该被触发。

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number, :if => :paid_with_card?
end
</ruby>

h4. Using +:if+ and +:unless+ with a String
h4. 使用String作为 +:if+和+:unless+的参数

You can also use a string that will be evaluated using +eval+ and hence needs to contain valid Ruby code. You should use this option only when the string represents a really short condition:
你也可以使用一个字符串作为参数传入，rails会使用+eval+执行，因此该字符串必须含有有效的Ruby代码。只有当条件判断语句很短的时候你才应该使用该方法。

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number, :if => "paid_with_card?"
end
</ruby>

h4. Using +:if+ and +:unless+ with a +Proc+
h4. 使用+Proc+作为+:if+和+:unless+的参数

Finally, it is possible to associate +:if+ and +:unless+ with a +Proc+ object. This option is best suited when writing short validation methods, usually one-liners:
其实我们还可以将一个+Proc+作为+:if+和+:unless+的参数传入。这种情况最适合于判断条件是很短的校验函数，通常是单行时使用。

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number,
    :if => Proc.new { |order| order.paid_with_card? }
end
</ruby>

h4. Multiple Conditions for Callbacks
h4. 回调前有多个条件判断

When writing conditional callbacks, it is possible to mix both +:if+ and +:unless+ in the same callback declaration:
当写有条件的回调时，可以将+:if+和+:unless+在同一个声明中同时混合使用：

<ruby>
class Comment < ActiveRecord::Base
  after_create :send_email_to_author, :if => :author_wants_emails?,
    :unless => Proc.new { |comment| comment.post.ignore_comments? }
end
</ruby>

h3. Callback Classes
h3. 回调类

Sometimes the callback methods that you'll write will be useful enough to be reused by other models. Active Record makes it possible to create classes that encapsulate the callback methods, so it becomes very easy to reuse them.
一些情况下，有些回调十分有用以至于可以重用到其他的模型中。Active Record可以让我们将回调方法封装起来，以方便我们日后重用。

Here's an example where we create a class with an +after_destroy+ callback for a +PictureFile+ model:
这里的例子中，我们可以为+PictureFile+模型创建可以含有+after_destroy+回调的类：

<ruby>
class PictureFileCallbacks
  def after_destroy(picture_file)
    if File.exists?(picture_file.filepath)
      File.delete(picture_file.filepath)
    end
  end
end
</ruby>

When declared inside a class, as above, the callback methods will receive the model object as a parameter. We can now use the callback class in the model:
如上所示，我们在类内部声明的回调方法需要接受一个模型对象作为参数。现在我们可以如下所示在模型中使用该回调：

<ruby>
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks.new
end
</ruby>

Note that we needed to instantiate a new +PictureFileCallbacks+ object, since we declared our callback as an instance method. This is particularly useful if the callbacks make use of the state of the instantiated object. Often, however, it will make more sense to declare the callbacks as class methods:
需要注意的是我们需要实例化一个+PictureFileCallbacks+对象，因为我们声明的回调是实例方法。当我们需要使用该实例对象的状态时，这就会很有用。通常来讲，将回调声明为一个类方法更加方便一些：

<ruby>
class PictureFileCallbacks
  def self.after_destroy(picture_file)
    if File.exists?(picture_file.filepath)
      File.delete(picture_file.filepath)
    end
  end
end
</ruby>

If the callback method is declared this way, it won't be necessary to instantiate a +PictureFileCallbacks+ object.
如果回调如上面一样声明为类方法，就不需要实例化+PictureFileCallbacks+对象了。

<ruby>
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks
end
</ruby>

You can declare as many callbacks as you want inside your callback classes.
回调类中，声明的回调方法的数量是不限制的。

h3. Observers
h3. 观察者 

Observers are similar to callbacks, but with important differences. Whereas callbacks can pollute a model with code that isn't directly related to its purpose, observers allow you to add the same functionality without changing the code of the model. For example, it could be argued that a +User+ model should not include code to send registration confirmation emails. Whenever you use callbacks with code that isn't directly related to your model, you may want to consider creating an observer instead.
观察者类似于回调，但是他们之间又有很重要的区别。回调会给模型中引入和模型没有直接关系的代码，而观察者可以达到相同的目的但是不更改模型的代码。例如，+User+模型不应该包含发送注册确认邮件的代码。当你使用的回调包含和模型不直接相关的代码时，你可能应该考虑使用观察者来代替它。

h4. Creating Observers
h4. 创建观察者 

For example, imagine a +User+ model where we want to send an email every time a new user is created. Because sending emails is not directly related to our model's purpose, we should create an observer to contain the code implementing this functionality.
例如，假如我们想在每当新用户被创建的时候，都会发送一封确认邮件。但是发送确认邮件并非和用户模型逻辑直接相关，所以我们应该创建一个观察者来实现这部分功能。

<shell>
$ rails generate observer User
</shell>

generates +app/models/user_observer.rb+ containing the observer class +UserObserver+:
会生成包含+UserObserver+类的+app/models/user_observer.rb+文件：

<ruby>
class UserObserver < ActiveRecord::Observer
end
</ruby>

You may now add methods to be called at the desired occasions:
添加在适当时间需要被调用的方法：

<ruby>
class UserObserver < ActiveRecord::Observer
  def after_create(model)
    # code to send confirmation email...
  end
end
</ruby>

As with callback classes, the observer's methods receive the observed model as a parameter.
和回调类一样，观察者类中的方法也是接受观察的模型作为参数。

h4. Registering Observers
h4. 注册观察者

Observers are conventionally placed inside of your +app/models+ directory and registered in your application's +config/application.rb+ file. For example, the +UserObserver+ above would be saved as +app/models/user_observer.rb+ and registered in +config/application.rb+ this way:
观察者通常放置在+app/models+文件夹下面，并在+config/application.rb+文件中注册。例如，上面的+UserObserver+应该保存为+app/models/user_observer.rb文件并在文件+config/application.rb+中如下注册：

<ruby>
# Activate observers that should always be running.
# 注册激活后的观察者会一直运行下去。 
config.active_record.observers = :user_observer
</ruby>

As usual, settings in +config/environments+ take precedence over those in +config/application.rb+. So, if you prefer that an observer doesn't run in all environments, you can simply register it in a specific environment instead.
通常来说，+config/environments+中配置的优先级高于在+config/application.rb+中的配置。所以，如果你并不想让观察者在所有的环境下运行，只需要在指定的环境文件中配置即可。

h4. Sharing Observers
h4. 分享观察者 

By default, Rails will simply strip "Observer" from an observer's name to find the model it should observe. However, observers can also be used to add behavior to more than one model, and thus it is possible to explicitly specify the models that our observer should observe:
默认情况下，Rails仅通过“观察者”的名称确定需要观察的模型。但是，观察者也可以被用来给多个模型添加同一行为，我们可以明确的指定需要观察的多个模型：

<ruby>
class MailerObserver < ActiveRecord::Observer
  observe :registration, :user

  def after_create(model)
    # code to send confirmation email...
  end
end
</ruby>

In this example, the +after_create+ method will be called whenever a +Registration+ or +User+ is created. Note that this new +MailerObserver+ would also need to be registered in +config/application.rb+ in order to take effect:
本例中，当+User+被创建后，+after_create+方法便会被调用。需要注意的是，这个新建的+MailerObserver+需要在+config/application.rb+中注册后才能生效：

<ruby>
# Activate observers that should always be running.
# 注册激活后的观察者会一直运行下去。 
config.active_record.observers = :mailer_observer
</ruby>

h3. Transaction Callbacks
h3. 事务回调

There are two additional callbacks that are triggered by the completion of a database transaction: +after_commit+ and +after_rollback+. These callbacks are very similar to the +after_save+ callback except that they don't execute until after database changes have either been committed or rolled back. They are most useful when your active record models need to interact with external systems which are not part of the database transaction.
有两个回调是在完成一次数据库事务操作后被触发的：+after_commit+和+after_rollback+。这两个回调和+after_save+很相似，只不过他们直到数据库操做成功完成或这失败后回滚发生后才被触发。当你的AR模型需要和不属于数据库事务的外部系统打交道时会非常的有用。

Consider, for example, the previous example where the +PictureFile+ model needs to delete a file after the corresponding record is destroyed. If anything raises an exception after the +after_destroy+ callback is called and the transaction rolls back, the file will have been deleted and the model will be left in an inconsistent state. For example, suppose that +picture_file_2+ in the code below is not valid and the +save!+ method raises an error.
考虑如下场景，前面的示例中+PictureFile+模型需要在被销毁时删除和他关联的图片文件。如果在+after_destroy+回调之后发生任何异常，事务回滚，但是图片文件已经被删除而且无法恢复，这回导致模型数据不一致。例如，假设下面代码中的+picture_file_2+是无效的，当我们执行+save!+方法时会抛出错误。

<ruby>
PictureFile.transaction do
  picture_file_1.destroy
  picture_file_2.save!
end
</ruby>

By using the +after_commit+ callback we can account for this case.
我们可以在这种情况下使用+after_commit+回调。

<ruby>
class PictureFile < ActiveRecord::Base
  attr_accessor :delete_file

  after_destroy do |picture_file|
    picture_file.delete_file = picture_file.filepath
  end

  after_commit do |picture_file|
    if picture_file.delete_file && File.exist?(picture_file.delete_file)
      File.delete(picture_file.delete_file)
      picture_file.delete_file = nil
    end
  end
end
</ruby>

The +after_commit+ and +after_rollback+ callbacks are guaranteed to be called for all models created, updated, or destroyed within a transaction block. If any exceptions are raised within one of these callbacks, they will be ignored so that they don't interfere with the other callbacks. As such, if your callback code could raise an exception, you'll need to rescue it and handle it appropriately within the callback.
+after_commit+和+after_rollback+回调被确保会在所有模型在一个事务中被创建，更新或者销毁时调用。如果这些回调中的任何一个抛出异常，他们会被忽略并且不会干涉其它的回调。所以，如果你的回调代码中可能抛出异常，你就需要在回调中捕获并适当的处理它。
