h2. Action Mailer 入门

这份文章能够让你了解如何用应用上手收发邮件，深入地了解 Action Mailer 组件，还介绍了测试自己邮件收发的方法。

endprologue.

WARNING. 这份教程基于 Rails 3.2 版本。 有的代码在更老旧版本的 Rails 上可能会出问题。

h3. Introduction

Action Mailer allows you to send emails from your application using a mailer model and views. So, in Rails, emails are used by creating mailers that inherit from +ActionMailer::Base+ and live in +app/mailers+. Those mailers have associated views that appear alongside controller views in +app/views+.

h3. Sending Emails

This section will provide a step-by-step guide to creating a mailer and its views.

h4. Walkthrough to Generating a Mailer

h5. Create the Mailer

<shell>
$ rails generate mailer UserMailer
create  app/mailers/user_mailer.rb
invoke  erb
create    app/views/user_mailer
invoke  test_unit
create    test/functional/user_mailer_test.rb
</shell>

So we got the mailer, the views, and the tests.

h5. Edit the Mailer

+app/mailers/user_mailer.rb+ contains an empty mailer:

<ruby>
class UserMailer < ActionMailer::Base
  default :from => "from@example.com"
end
</ruby>

Let's add a method called +welcome_email+, that will send an email to the user's registered email address:

<ruby>
class UserMailer < ActionMailer::Base
  default :from => "notifications@example.com"

  def welcome_email(user)
    @user = user
    @url  = "http://example.com/login"
    mail(:to => user.email, :subject => "欢迎来到我的网站")
  end
end
</ruby>

这里的方法就展示了一个简单的邮件项目，要想用上更多可用的选项，你可以在下文中可以找到一个完整的 Action Mailer 的参数设置选项表。而在这里

* <tt>default 哈希</tt> - 这是一个邮件的必选参数，在这个例子里我们在类的顶部设定了<tt>:from</tt>参数，这个参数是可以在每封具体邮件的内部修改的。
* +mail+ - 在这个 email 文件中，我们对其设置了 <tt>:to</tt> 和 <tt>:subject</tt> 参数.

就和控制器一样，我们这个类的实例方法中定义的任何变量都将可以用在 View 中使用。

h5. 创建 Mailer 视图

我们在  +app/views/user_mailer/+ 建立一个 Email 的模板文件叫 +welcome_email.html.erb+，用 HTML 语言进行书写它：

<erb>
<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  </head>
  <body>
    <h1>Welcome to example.com, <%= @user.name %></h1>
    <p>
      You have successfully signed up to example.com,
      your username is: <%= @user.login %>.<br/>
    </p>
    <p>
      To login to the site, just follow this link: <%= @url %>.
    </p>
    <p>Thanks for joining and have a great day!</p>
  </body>
</html>
</erb>

为你的 email 的文字部分分离出来会是不错的选择，在 +app/views/user_mailer/+ 下建立一个文件 +welcome_email.text.erb+：

<erb>
Welcome to example.com, <%= @user.name %>
===============================================

You have successfully signed up to example.com,
your username is: <%= @user.login %>.

To login to the site, just follow this link: <%= @url %>.

Thanks for joining and have a great day!
</erb>

当你调用了 +mail+ 方法之后， Action Mailer 将会为你检测两种模板文件(text 和 HTML)然后为你自动生成一个 email 文件。

h5. 用户注册后自动发送邮件

这里有几种方法来实现这件事情，有的人会建立一个 Rails 观察者模型来监视注册事件，还有一些人会在用户模型中实现这一功能。然而，在 Rails 3 中，mailer 有了第三种方法去实现它，与原来渲染视图之后通过 HTTP 协议发送，他们现在只需要通过 Email 协议直接发送邮件就可以了。因此，你可以在用户成功注册之后直接通过控制器来发送命令给 mailer 发送邮件。

而要做到这样的功能简直是易如反掌。

首先我们先建立一个 User scaffold：

<shell>
$ rails generate scaffold user name:string email:string login:string
$ rake db:migrate
</shell>

这样我们就有了 用户模型了，我们将要编辑 +app/controllers/users_controller.rb+ 来让 UserMailer 为新建立的用户发送一封邮件，我们在 create 行为中当用户成功 save 之后调用了一个方法<tt>UserMailer.welcome_email</tt>。

<ruby>
class UsersController < ApplicationController
  # POST /users
  # POST /users.json
  def create
    @user = User.new(params[:user])

    respond_to do |format|
      if @user.save
        # Tell the UserMailer to send a welcome Email after save
        UserMailer.welcome_email(@user).deliver

        format.html { redirect_to(@user, :notice => 'User was successfully created.') }
        format.json { render :json => @user, :status => :created, :location => @user }
      else
        format.html { render :action => "new" }
        format.json { render :json => @user.errors, :status => :unprocessable_entity }
      end
    end
  end
end
</ruby>

这样就轻松地实现了目标，不需要观察者之类的东西。
方法 +welcome_email+ 返回一个 <tt>Mail::Message</tt> 对象，它会像 +deliver+ 请求把它自己发送出去。

NOTE: 在过去几个版本里的 Rails ，你需要调用 +deliver_welcome_email+ 或 +create_welcome_email+。它们在 Rails 3.0 中被弃用了，你只需要调用这个方法名本身即可。

WARNING: 发送一封邮件可能需要花费将近一秒的时间，如果你需要一次性发送好几封邮件，或者你不想因此降低主机的处理俗入，你恐怕要考虑下使用一个后台处理软件，例如 Delayed　Job.

h4. 多字节问题

Action Mailer 已经解决了文中的多字节编码问题。

如果你用　UTF-8　作为你的字符集，你什么都不用做，直接用　UTF-8　编码填写邮件地址，主题，关键词，文件名和邮件正文，如果邮件头部或者正文中出现了非　US-ASCII　编码部分， Action Mailer 会自动把他们转码为可读的版本（quoted printable）。

关于更为复杂的编码问题，例如在正文中编写了多种字符集，请参考　Ｍａｉｌ　类库。　

h4. Action Mailer 方法全列表

其实不管你发什么邮件都只需要三个方法就够了：

* <tt>headers</tt> - 指定你邮件的头部，你可以传入一个哈希来把头部作为数据的键值对，然后你就可以这么用 <tt>headers[:field_name] = 'value'</tt>
* <tt>attachments</tt> - 允许你添加附件到你的　ｅｍａｉｌ　中　例如 <tt>attachments['file-name.jpg'] = File.read('file-name.jpg')</tt>
* <tt>mail</tt> - 发送邮件。你可以把头部数据以哈希的形式传入， mail　将会根据你的模板生成　Ｅｍａｉｌ　.

h5. 自定义头部部分

自定义头部很简单，你只需要用三步就能够完成：

* 把头部作为一个参数传入　+mail+ 方法:
　
<ruby>
mail("X-Spam" => value)
</ruby>

* 传递一个键值对参数到　+headers+　方法:

<ruby>
headers["X-Spam"] = value
</ruby>

* 传递一个哈希到　+headers+　方法:

<ruby>
headers {"X-Spam" => value, "X-Special" => another_value}
</ruby>

TIP: 所有的 <tt>X-Value</tt> 头部　每 RFC2822 可以出现多次. 如果你想要删除一个　<tt>X-Value</tt>　头，你需要将其值声明成　<tt>nil</tt> .

h5. 添加附件

添加附件在　Action Mailer 3.0　中得到了大大的简化.

* 只要传入　文件名的内容之后 Action Mailer 和 Mail 插件将会自动对其　mime_type　进行检测，并对应进行编码和创建附件.

<ruby>
attachments['filename.jpg'] = File.read('/path/to/filename.jpg')
</ruby>

NOTE: Mail 插件将会自动地将附件进行　Base64　编码, 如果你对这一特性不太满意，你可以将其事先编码之后把内容和编码形式用哈希一并传入　+attachments+ 方法.

* 传入文件名和特殊的头部内容，为　Action Mailer 和 Mail　进行设置.

<ruby>
encoded_content = SpecialEncode(File.read('/path/to/filename.jpg'))
attachments['filename.jpg'] = {:mime_type => 'application/x-gzip',
                               :encoding => 'SpecialEncoding',
                               :content => encoded_content }
</ruby>

NOTE: 如果你用了一种指定的编码形式， Mail　将会认为你的内容是已经经过编码的，并不再尝试地对其内容进行　Base64 编码.

h5. Making Inline Attachments

Action Mailer 3.0 makes inline attachments, which involved a lot of hacking in pre 3.0 versions, much simpler and trivial as they should be.

* Firstly, to tell Mail to turn an attachment into an inline attachment, you just call <tt>#inline</tt> on the attachments method within your Mailer:

<ruby>
def welcome
  attachments.inline['image.jpg'] = File.read('/path/to/image.jpg')
end
</ruby>

* Then in your view, you can just reference <tt>attachments[]</tt> as a hash and specify which attachment you want to show, calling +url+ on it and then passing the result into the <tt>image_tag</tt> method:

<erb>
<p>Hello there, this is our image</p>

<%= image_tag attachments['image.jpg'].url %>
</erb>

* As this is a standard call to +image_tag+ you can pass in an options hash after the attachment url as you could for any other image:

<erb>
<p>Hello there, this is our image</p>

<%= image_tag attachments['image.jpg'].url, :alt => 'My Photo',
                                            :class => 'photos' %>
</erb>

h5. Sending Email To Multiple Recipients

It is possible to send email to one or more recipients in one email (for e.g. informing all admins of a new signup) by setting the list of emails to the <tt>:to</tt> key. The list of emails can be an array of email addresses or a single string with the addresses separated by commas.

<ruby>
class AdminMailer < ActionMailer::Base
  default :to => Proc.new { Admin.pluck(:email) },
          :from => "notification@example.com"

  def new_registration(user)
    @user = user
    mail(:subject => "New User Signup: #{@user.email}")
  end
end
</ruby>

The same format can be used to set carbon copy (Cc:) and blind carbon copy (Bcc:) recipients, by using the <tt>:cc</tt> and <tt>:bcc</tt> keys respectively.

h5. Sending Email With Name

Sometimes you wish to show the name of the person instead of just their email address when they receive the email. The trick to doing that is
to format the email address in the format <tt>"Name &lt;email&gt;"</tt>.

<ruby>
def welcome_email(user)
  @user = user
  email_with_name = "#{@user.name} <#{@user.email}>"
  mail(:to => email_with_name, :subject => "Welcome to My Awesome Site")
end
</ruby>

h4. Mailer Views

Mailer views are located in the +app/views/name_of_mailer_class+ directory. The specific mailer view is known to the class because its name is the same as the mailer method. In our example from above, our mailer view for the +welcome_email+ method will be in +app/views/user_mailer/welcome_email.html.erb+ for the HTML version and +welcome_email.text.erb+ for the plain text version.

To change the default mailer view for your action you do something like:

<ruby>
class UserMailer < ActionMailer::Base
  default :from => "notifications@example.com"

  def welcome_email(user)
    @user = user
    @url  = "http://example.com/login"
    mail(:to => user.email,
         :subject => "Welcome to My Awesome Site",
         :template_path => 'notifications',
         :template_name => 'another')
  end
end
</ruby>

In this case it will look for templates at +app/views/notifications+ with name +another+.

If you want more flexibility you can also pass a block and render specific templates or even render inline or text without using a template file:

<ruby>
class UserMailer < ActionMailer::Base
  default :from => "notifications@example.com"

  def welcome_email(user)
    @user = user
    @url  = "http://example.com/login"
    mail(:to => user.email,
         :subject => "Welcome to My Awesome Site") do |format|
      format.html { render 'another_template' }
      format.text { render :text => 'Render text' }
    end
  end

end
</ruby>

This will render the template 'another_template.html.erb' for the HTML part and use the rendered text for the text part. The render command is the same one used inside of Action Controller, so you can use all the same options, such as <tt>:text</tt>, <tt>:inline</tt> etc.

h4. Action Mailer Layouts

Just like controller views, you can also have mailer layouts. The layout name needs to be the same as your mailer, such as +user_mailer.html.erb+ and +user_mailer.text.erb+ to be automatically recognized by your mailer as a layout.

In order to use a different file just use:

<ruby>
class UserMailer < ActionMailer::Base
  layout 'awesome' # use awesome.(html|text).erb as the layout
end
</ruby>

Just like with controller views, use +yield+ to render the view inside the layout.

You can also pass in a <tt>:layout => 'layout_name'</tt> option to the render call inside the format block to specify different layouts for different actions:

<ruby>
class UserMailer < ActionMailer::Base
  def welcome_email(user)
    mail(:to => user.email) do |format|
      format.html { render :layout => 'my_layout' }
      format.text
    end
  end
end
</ruby>

Will render the HTML part using the <tt>my_layout.html.erb</tt> file and the text part with the usual <tt>user_mailer.text.erb</tt> file if it exists.

h4. Generating URLs in Action Mailer Views

URLs can be generated in mailer views using +url_for+ or named routes.

Unlike controllers, the mailer instance doesn't have any context about the incoming request so you'll need to provide the +:host+, +:controller+, and +:action+:

<erb>
<%= url_for(:host => "example.com",
            :controller => "welcome",
            :action => "greeting") %>
</erb>

When using named routes you only need to supply the +:host+:

<erb>
<%= user_url(@user, :host => "example.com") %>
</erb>

Email clients have no web context and so paths have no base URL to form complete web addresses. Thus, when using named routes only the "_url" variant makes sense.

It is also possible to set a default host that will be used in all mailers by setting the <tt>:host</tt> option as a configuration option in <tt>config/application.rb</tt>:

<ruby>
config.action_mailer.default_url_options = { :host => "example.com" }
</ruby>

If you use this setting, you should pass the <tt>:only_path => false</tt> option when using +url_for+. This will ensure that absolute URLs are generated because the +url_for+ view helper will, by default, generate relative URLs when a <tt>:host</tt> option isn't explicitly provided.

h4. Sending Multipart Emails

Action Mailer will automatically send multipart emails if you have different templates for the same action. So, for our UserMailer example, if you have +welcome_email.text.erb+ and +welcome_email.html.erb+ in +app/views/user_mailer+, Action Mailer will automatically send a multipart email with the HTML and text versions setup as different parts.

The order of the parts getting inserted is determined by the <tt>:parts_order</tt> inside of the <tt>ActionMailer::Base.default</tt> method. If you want to explicitly alter the order, you can either change the <tt>:parts_order</tt> or explicitly render the parts in a different order:

<ruby>
class UserMailer < ActionMailer::Base
  def welcome_email(user)
    @user = user
    @url  = user_url(@user)
    mail(:to => user.email,
         :subject => "Welcome to My Awesome Site") do |format|
      format.html
      format.text
    end
  end
end
</ruby>

Will put the HTML part first, and the plain text part second.

h4. Sending Emails with Attachments

Attachments can be added by using the +attachments+ method:

<ruby>
class UserMailer < ActionMailer::Base
  def welcome_email(user)
    @user = user
    @url  = user_url(@user)
    attachments['terms.pdf'] = File.read('/path/terms.pdf')
    mail(:to => user.email,
         :subject => "Please see the Terms and Conditions attached")
  end
end
</ruby>

The above will send a multipart email with an attachment, properly nested with the top level being <tt>multipart/mixed</tt> and the first part being a <tt>multipart/alternative</tt> containing the plain text and HTML email messages.

h3. Receiving Emails

Receiving and parsing emails with Action Mailer can be a rather complex endeavor. Before your email reaches your Rails app, you would have had to configure your system to somehow forward emails to your app, which needs to be listening for that. So, to receive emails in your Rails app you'll need to:

* Implement a +receive+ method in your mailer.

* Configure your email server to forward emails from the address(es) you would like your app to receive to +/path/to/app/script/rails runner 'UserMailer.receive(STDIN.read)'+.

Once a method called +receive+ is defined in any mailer, Action Mailer will parse the raw incoming email into an email object, decode it, instantiate a new mailer, and pass the email object to the mailer +receive+ instance method. Here's an example:

<ruby>
class UserMailer < ActionMailer::Base
  def receive(email)
    page = Page.find_by_address(email.to.first)
    page.emails.create(
      :subject => email.subject,
      :body => email.body
    )

    if email.has_attachments?
      email.attachments.each do |attachment|
        page.attachments.create({
          :file => attachment,
          :description => email.subject
        })
      end
    end
  end
end
</ruby>

h3. Using Action Mailer Helpers

Action Mailer now just inherits from Abstract Controller, so you have access to the same generic helpers as you do in Action Controller.

h3. Action Mailer Configuration

The following configuration options are best made in one of the environment files (environment.rb, production.rb, etc...)

|+template_root+|Determines the base from which template references will be made.|
|+logger+|Generates information on the mailing run if available. Can be set to +nil+ for no logging. Compatible with both Ruby's own +Logger+ and +Log4r+ loggers.|
|+smtp_settings+|Allows detailed configuration for <tt>:smtp</tt> delivery method:<ul><li><tt>:address</tt> - Allows you to use a remote mail server. Just change it from its default "localhost" setting.</li><li><tt>:port</tt>  - On the off chance that your mail server doesn't run on port 25, you can change it.</li><li><tt>:domain</tt> - If you need to specify a HELO domain, you can do it here.</li><li><tt>:user_name</tt> - If your mail server requires authentication, set the username in this setting.</li><li><tt>:password</tt> - If your mail server requires authentication, set the password in this setting.</li><li><tt>:authentication</tt> - If your mail server requires authentication, you need to specify the authentication type here. This is a symbol and one of <tt>:plain</tt>, <tt>:login</tt>, <tt>:cram_md5</tt>.</li></ul>|
|+sendmail_settings+|Allows you to override options for the <tt>:sendmail</tt> delivery method.<ul><li><tt>:location</tt> - The location of the sendmail executable. Defaults to <tt>/usr/sbin/sendmail</tt>.</li><li><tt>:arguments</tt> - The command line arguments to be passed to sendmail. Defaults to <tt>-i -t</tt>.</li></ul>|
|+raise_delivery_errors+|Whether or not errors should be raised if the email fails to be delivered.|
|+delivery_method+|Defines a delivery method. Possible values are <tt>:smtp</tt> (default), <tt>:sendmail</tt>, <tt>:file</tt> and <tt>:test</tt>.|
|+perform_deliveries+|Determines whether deliveries are actually carried out when the +deliver+ method is invoked on the Mail message. By default they are, but this can be turned off to help functional testing.|
|+deliveries+|Keeps an array of all the emails sent out through the Action Mailer with delivery_method :test. Most useful for unit and functional testing.|

h4. Example Action Mailer Configuration

An example would be adding the following to your appropriate <tt>config/environments/$RAILS_ENV.rb</tt> file:

<ruby>
config.action_mailer.delivery_method = :sendmail
# Defaults to:
# config.action_mailer.sendmail_settings = {
#   :location => '/usr/sbin/sendmail',
#   :arguments => '-i -t'
# }
config.action_mailer.perform_deliveries = true
config.action_mailer.raise_delivery_errors = true
</ruby>

h4. Action Mailer Configuration for GMail

As Action Mailer now uses the Mail gem, this becomes as simple as adding to your <tt>config/environments/$RAILS_ENV.rb</tt> file:

<ruby>
config.action_mailer.delivery_method = :smtp
config.action_mailer.smtp_settings = {
  :address              => "smtp.gmail.com",
  :port                 => 587,
  :domain               => 'baci.lindsaar.net',
  :user_name            => '<username>',
  :password             => '<password>',
  :authentication       => 'plain',
  :enable_starttls_auto => true  }
</ruby>

h3. Mailer Testing

By default Action Mailer does not send emails in the test environment. They are just added to the +ActionMailer::Base.deliveries+ array.

Testing mailers normally involves two things: One is that the mail was queued, and the other one that the email is correct. With that in mind, we could test our example mailer from above like so:

<ruby>
class UserMailerTest < ActionMailer::TestCase
  def test_welcome_email
    user = users(:some_user_in_your_fixtures)

    # Send the email, then test that it got queued
    email = UserMailer.welcome_email(user).deliver
    assert !ActionMailer::Base.deliveries.empty?

    # Test the body of the sent email contains what we expect it to
    assert_equal [user.email], email.to
    assert_equal "Welcome to My Awesome Site", email.subject
    assert_match(/<h1>Welcome to example.com, #{user.name}<\/h1>/, email.encoded)
    assert_match(/Welcome to example.com, #{user.name}/, email.encoded)
  end
end
</ruby>

In the test we send the email and store the returned object in the +email+ variable. We then ensure that it was sent (the first assert), then, in the second batch of assertions, we ensure that the email does indeed contain what we expect.
