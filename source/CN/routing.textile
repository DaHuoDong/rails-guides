h2. 深入浅出说路由

这份教程介绍了 Rails 路由常用的特性。通过本文，你将会能够：

* 了解 +routes.rb+ 中的代码。
* 用 Resourceful 风格或者 tt>match</tt> 方法 构建你的路由
* 了解一个 action 是如何接收从路由来的参数。
* 用路由提供的 helper 来生成 URL 路径。
* 一些更高级的技巧，例如 constraints and Rack endpoints。

endprologue.

h3. Rails 路由的意义

Rails 路由能够识别 URL 并且将请求分发到对应的 控制器下的 action 中。 它也可以生成相对路径和 URL 来避免在你的视图中的硬编码（hardcode string）.

h4. 链接 URL 和代码

当你的 Rails 应用接收到一个像这样的请求时

<plain>
GET /patients/17
</plain>
 
它就会尝试着让路由去匹配字符串到一个控制器行为中。如果第一条路由规则是这样的：

<ruby>
match "/patients/:id" => "patients#show"
</ruby>

这个请求将会被分发到 +patients+ 控制器下面的 +show+ action 中去，同时 <tt>{ :id => "17" }</tt> 将会存储在 +params+ 中。

h4. 用代码生成 URL 和 路径

你同样可以用路由来生成 URl 和路径，如果你的应用包含了这样的代码：

<ruby>
@patient = Patient.find(17)
</ruby>

<erb>
<%= link_to "Patient Record", patient_path(@patient) %>
</erb>

路由将会自动生成一个路径 +/patients/17+ ，这将使你的代码更加简洁易懂而健壮。注意这里我们没必要将 id 传递给路由 Helper。

h3. Resource 路由规则: Rails 之道

Resource 路由规则能让你迅速地构建出 resourceful 的控制器所需常用路由规则，它可以自动地为你生成 +index+, +show+, +new+, +edit+, +create+, +update+ 和 +destroy+ 行为，而一个 Resourceful 的路由声明只需要一行代码。
 

h4. web 与 Resource

浏览器向 Rails 的一个页面发起请求 URL 的时候必须要指定一个 HTTP 请求方法，例如 +GET+, +POST+, +PATCH+, +PUT+ and +DELETE+.这些方法将会对 Rails 中的资源进行不同的操作。而一个 Resource 的路由规则将会为一个控制器自动匹配多种相关方法。

例如，当你的 Rails 程序接收到了这样的请求：

<plain>
DELETE /photos/17
</plain>

它会向 路由请求匹配到一个控制器行为上，这里假设匹配上了我们路由上的这条规则

<ruby>
resources :photos
</ruby>

Rails 就将会把这个请求分发到 +photos+ 控制器下的 +destroy+ 方法下，并且把 <tt>{ :id => "17" }</tt> 作为 +params+ 的值.

h4. CRUD, Verbs, Actions

对于 Rails 一个 Resourceful 的路由提供了一组 HTTP 和 控制器行为的对应关系。它还约定了与每个行为相对应的 CRUD 的数据库操作。例如这样的一个 简单的 路由记录：

<ruby>
resources :photos
</ruby>

将会在应用中生成七个不同的路由记录，他们都会匹配到 +Photos+ 控制器上去。

|_. HTTP Verb |_.Path            |_.action |_.used for                                   |
|GET          |/photos           |index    |display a list of all photos                 |
|GET          |/photos/new       |new      |return an HTML form for creating a new photo |
|POST         |/photos           |create   |create a new photo                           |
|GET          |/photos/:id       |show     |display a specific photo                     |
|GET          |/photos/:id/edit  |edit     |return an HTML form for editing a photo      |
|PATCH/PUT    |/photos/:id       |update   |update a specific photo                      |
|DELETE       |/photos/:id       |destroy  |delete a specific photo                      |

NOTE: Rails 路由的匹配是按照规则顺序匹配的，所以如果在你的路由规则中有一句 +resources :photos+，接着一句 +get 'photos/poll'+， 这样的话 +resources+ 定义的 +show+ 这个行为会比 +get+ 方法优先完成匹配。如果这样并非是你的本意，你只要将 +get 'photos/poll'+ 调到 +resources+ 那行的前面就可以先行指定特别的匹配规则。

h4.  URL 和 Path

建立一个 Resourceful 的路由的同时也会为你的应用自动添加一系列的 Helper 方法。以上面的 +resources :photos+ 路由规则为例：

* +photos_path+ 会返回 +/photos+
* +new_photo_path+ 返回 +/photos/new+
* +edit_photo_path(:id)+ 返回 +/photos/:id/edit+ (例如, +edit_photo_path(10)+ 返回 +/photos/10/edit+)
* +photo_path(:id)+ 返回 +/photos/:id+ (例如, +photo_path(10)+ returns +/photos/10+)

同时，这些 +_path+ Helper 方法还有一个对应的 +_url+ Helper (例如 +photos_url+) 
后者将会返回包含了主机，端口等信息的绝对路径地址。

NOTE: 因为路由器可以使用 HTTP 动词 加上一个 URL 来匹配受到的请求，所以四个不同的 URL 可以组合出7种不同的行为。

h4. 同时定义多个 Resource  

如果你想在路由表中建立多个 Resource， 你可以把他们写到一行里面去，这样只需要调用一个 +resources+ ，同时为你节约点输入时间：

<ruby>
resources :photos, :books, :videos
</ruby>

它和下面这样写的效果是一样的：

<ruby>
resources :photos
resources :books
resources :videos
</ruby>

h4. 单件 Resources

有时候，你并不需要一个能够根据ID查询个体的 resource 。例如，你可能会想用 +/profile+ 来显示当前登录用户的简介，这时候你可以用 map +/profile+ (或者 +/profile/:id+) 一个单体化的 Resource 来匹配 show 行为。

<ruby>
match "profile" => "users#show"                           
</ruby>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
或者这样来声明一个 Resourceful 的资源：

<ruby>
resource :geocoder
</ruby>

它会为你的应用建立六个不同的 routes ，都将匹配到 +Geocoders+ 控制器:

|_.HTTP Verb |_.Path         |_.action |_.used for                                    |
|GET         |/geocoder/new  |new      |return an HTML form for creating the geocoder |
|POST        |/geocoder      |create   |create the new geocoder                       |
|GET         |/geocoder      |show     |display the one and only geocoder resource    |
|GET         |/geocoder/edit |edit     |return an HTML form for editing the geocoder  |
|PATCH/PUT   |/geocoder      |update   |update the one and only geocoder resource     |
|DELETE      |/geocoder      |destroy  |delete the geocoder resource                  |

NOTE: 因为你可能要在路由中同时使用单数 (+/account+) 和 复数 （+/accounts/45+） 而想要对应同一个控制器，所以单件 Resource 命令也是对应复数的控制器。

一个 单件 Resourceful 路由生成这些 Helper 方法：

* +new_geocoder_path+ 返回 +/geocoder/new+
* +edit_geocoder_path+ 返回 +/geocoder/edit+
* +geocoder_path+ 返回 +/geocoder+

同复数的 resources 命令一样，以 +_url+ 结尾的  Hepler 将会包括主机名，端口值和其他的相关路径前缀。

h4. 控制器、命名空间(Namespaces),和路由

有时，你可以想要把一些同类的控制器组织到一个命名空间下面去，其中最常见的就是我们会把一组管理功能的控制器放到 +Admin::+ 下，然后把这个空间下的控制器都放在 +app/controllers/admin+ 目录下，并且统一在路由中配置：

<ruby>
namespace :admin do
  resources :posts, :comments
end
</ruby>

这样将会为每一个 +posts+ 和 +comments+ 方法建立一个路由规则，对于 +Admin::PostsController+， Rails 会建立这些路由表规则：

|_.HTTP Verb |_.Path                |_.action |_.named helper             |
|GET         |/admin/posts          |index    | admin_posts_path          |
|GET         |/admin/posts/new      |new      | new_admin_post_path       |
|POST        |/admin/posts          |create   | admin_posts_path          |
|GET         |/admin/posts/:id      |show     | admin_post_path(:id)      |
|GET         |/admin/posts/:id/edit |edit     | edit_admin_post_path(:id) |
|PATCH/PUT   |/admin/posts/:id      |update   | admin_post_path(:id)      |
|DELETE      |/admin/posts/:id      |destroy  | admin_post_path(:id)      |

如果你想要把路由 +/posts+ (不以 +/admin+ 作前缀) 匹配到 +Admin::PostsController+，你就需要这样了：

<ruby>
scope :module => "admin" do
  resources :posts, :comments
end
</ruby>

或者对单个 Resource 匹配的时候

<ruby>
resources :posts, :module => "admin"
</ruby>

而你如果想要把路由：+/admin/posts+ 给匹配到 +PostsController+ (控制器中没有 +Admin::+ 这个模块作为前缀)，你可以用

<ruby>
scope "/admin" do
  resources :posts, :comments
end
</ruby>

或者在为单个 Resource 匹配的时候这么写：

<ruby>
resources :posts, :path => "/admin/posts"
</ruby>

在这些例子里面，可以发现 scope 并不会改变 routes 的生成的路径名称的（译者注：named routes，这里指的是生成的Helper的名称。） ，例如在最后一个例子里面，会生成匹配到  +PostsController+的规则:

|_.HTTP Verb |_.Path               |_.action |_.named helper      |
|GET         |/admin/posts         |index    | posts_path         |
|GET         |/admin/posts/new     |new      | new_post_path      |
|POST        |/admin/posts         |create   | posts_path         |
|GET         |/admin/posts/:id     |show     | post_path(:id)     |
|GET         |/admin/posts/:id/edit|edit     | edit_post_path(:id)|
|PATCH/PUT   |/admin/posts/:id     |update   | post_path(:id)     |
|DELETE      |/admin/posts/:id     |destroy  | post_path(:id)     |

h4. 嵌套(Nested)数组

通常，一个 Resource 常常有数个逻辑上的子 Resource 。例如，你的应用有这样一个模型：

<ruby>
class Magazine < ActiveRecord::Base
  has_many :ads
end

class Ad < ActiveRecord::Base
  belongs_to :magazine
end
</ruby>

Nested routes allow you to capture this relationship in your routing. In this case, you could include this route declaration:

<ruby>
resources :magazines do
  resources :ads
end
</ruby>

在这里，对于每一个 magazines 的路径下面都需要能够有 ad 作为 Resource 匹配到+AdsController+。 这时候每一组 ad 都需要指定一个 magzine 作为前缀。

|_.HTTP Verb |_.Path                               |_.action |_.used for                                                                 |
|GET         |/magazines/:magazine_id/ads          |index    |display a list of all ads for a specific magazine                          |
|GET         |/magazines/:magazine_id/ads/new      |new      |return an HTML form for creating a new ad belonging to a specific magazine |
|POST        |/magazines/:magazine_id/ads          |create   |create a new ad belonging to a specific magazine                           |
|GET         |/magazines/:magazine_id/ads/:id      |show     |display a specific ad belonging to a specific magazine                     |
|GET         |/magazines/:magazine_id/ads/:id/edit |edit     |return an HTML form for editing an ad belonging to a specific magazine     |
|PATCH/PUT   |/magazines/:magazine_id/ads/:id      |update   |update a specific ad belonging to a specific magazine                      |
|DELETE      |/magazines/:magazine_id/ads/:id      |destroy  |delete a specific ad belonging to a specific magazine                      |

这样生成的路由 Hepler 就会是  +magazine_ads_url+ 和 +edit_magazine_ad_path+。这个帮助方法会把第一个参数当作指定 Magazine 的实例(例如 +magazine_ads_url(@magazine)+)。

h5. 嵌套 Resources 的限制

你可以把多个 Resources 一起嵌套起来。例如：

<ruby>
resources :publishers do
  resources :magazines do
    resources :photos
  end
end
</ruby>

但是多层的嵌套很快会让你的路由变得笨重。例如上面那个例子里，你需要这样来访问一个照片：

<pre>
/publishers/1/magazines/2/photos/3
</pre>

相关的路由 helper 会变成 +publisher_magazine_photo_url+ ，而且需要在参数中传入指定的每一个实例。事实上，这种令人郁闷的情形已经被很多人讨论过了，Jamis Buck 在 "这里":http://weblog.jamisbuck.org/2007/2/5/nesting-resources 有一份很火的 _Rails 路由设计简则_ ，这个问题或许可以在那里找到答案。

TIP: _事实上，你无法建立超过一层深的嵌套 Resources._

h4. 从对象到路径 URL

关于 路由 Helper, Rails 还可以通过传入一组参数来建立 路径或 URL，例如，你设置了这样的一组路由：

<ruby>
resources :magazines do
  resources :ads
end
</ruby>

当你使用 +magazine_ad_path+ 时，你可以把  +Magazine+ 和 +Ad+ 实例传入作参数来作为 ID。

<erb>
<%= link_to "Ad details", magazine_ad_path(@magazine, @ad) %>
</erb>

你也可以用 +url_for+ 带上一组对象，Rails 将会自动地生成正确的路由。

<erb>
<%= link_to "Ad details", url_for([@magazine, @ad]) %>
</erb>

在这里，Rails 将会把 +@magazine+ 对应到 +Magazine+， +@ad+ 对应到 +Ad+ 上去，然后决定使用 +magazine_ad_path+ 这个 Helper。而如果你用的是 +link_to+ 这样的Helper，你可以和调用 +url_for+ 一样用对象作参数:

<erb>
<%= link_to "Ad details", [@magazine, @ad] %>
</erb>

如果你并没有用嵌套式的路由，只要这样就可以访问一个对象的 show 方法：

<erb>
<%= link_to "Magazine details", @magazine %>
</erb>

如果你要指定对象的其他动作的话你也可以这样：

<erb>
<%= link_to "Edit Ad", [:edit, @magazine, @ad] %>
</erb>

这样就能把你的模型和 URL 有效的结合起来了，而且这也是一个很棒很 Resourceful 的特性。

h4. 加入额外的 RESTful 行为

除了7个默认创建的 RESTful 路由之外，如果你喜欢，你可以将一些额外的路由应用到你的物件集合或者单个的物件下面。

h5. 成员(Member)路由

加入一个成员路由只需要在你的 +resource+ 代码块中加入你一个 +member+ 代码块就好：

<ruby>
resources :photos do
  member do
    get 'preview'
  end
end
</ruby>

这样将会把 +/photos/1/preview+ 的 GET 动作识别出来，然后路由会匹配到 +PhotosController+ 控制器下面的 +preview+ 行为中。它同样会建立两个Helper：+preview_photo_url+ 和 +preview_photo_path+。

当你使用了路由中的 Member 代码块时，你可以任意指定一个HTTP动词： +get+, +patch+, +put+, +post+, 或者 +delete+ 。如果你并没有太多的 Member 路由规则，可以用  +:on+ 作为后缀来把代码块替换掉：

<ruby>
resources :photos do
  get 'preview', :on => :member
end
</ruby>

h5. 集合(Collection)路由

要想加入一个集合路由：

<ruby>
resources :photos do
  collection do
    get 'search'
  end
end
</ruby>

上面这段代码将会让 Rails 用 GET 方法匹配路径 +/photos/search+。并且这个 +search+ 行为将会匹配到 +PhotosController+下，它将会创建  +search_photos_url+ 和 +search_photos_path+ 两个路由Helper。

同成员路由一样，你可以传入一个 +:on+ 选项。

<ruby>
resources :photos do
  get 'search', :on => :collection
end
</ruby>

h5. 注意事项

如果你发现自己对 Resourceful 路由加入了太多的额外规则，是时候停下来好好审视下你是不是应该创建另一个 resource。

h3. 非 Resourceful 路由

对于 Resourceful 的路由，Rails 有着一整套强大的路由和行为支持，即使如此，你有时候可能也会需要一些不是由 Rails 成组生成的路由，这时候，你就需要把规则手动地一个一个输入到你的应用中去了。

While you should usually use resourceful routing, there are still many places where the simpler routing is more appropriate. There's no need to try to shoehorn every last piece of your application into a resourceful framework if that's not a good fit.

In particular, simple routing makes it very easy to map legacy URLs to new Rails actions.

h4. Bound Parameters

When you set up a regular route, you supply a series of symbols that Rails maps to parts of an incoming HTTP request. Two of these symbols are special: +:controller+ maps to the name of a controller in your application, and +:action+ maps to the name of an action within that controller. For example, consider one of the default Rails routes:

<ruby>
match ':controller(/:action(/:id))'
</ruby>

If an incoming request of +/photos/show/1+ is processed by this route (because it hasn't matched any previous route in the file), then the result will be to invoke the +show+ action of the +PhotosController+, and to make the final parameter +"1"+ available as +params[:id]+. This route will also route the incoming request of +/photos+ to +PhotosController#index+, since +:action+ and +:id+ are optional parameters, denoted by parentheses.

h4. Dynamic Segments

You can set up as many dynamic segments within a regular route as you like. Anything other than +:controller+ or +:action+ will be available to the action as part of +params+. If you set up this route:

<ruby>
match ':controller/:action/:id/:user_id'
</ruby>

An incoming path of +/photos/show/1/2+ will be dispatched to the +show+ action of the +PhotosController+. +params[:id]+ will be +"1"+, and +params[:user_id]+ will be +"2"+.

NOTE: You can't use +:namespace+ or +:module+ with a +:controller+ path segment. If you need to do this then use a constraint on :controller that matches the namespace you require. e.g:

<ruby>
match ':controller(/:action(/:id))', :controller => /admin\/[^\/]+/
</ruby>

TIP: By default dynamic segments don't accept dots - this is because the dot is used as a separator for formatted routes. If you need to use a dot within a dynamic segment add a constraint which overrides this - for example +:id+ => /[^\/]+/ allows anything except a slash.

h4. Static Segments

You can specify static segments when creating a route:

<ruby>
match ':controller/:action/:id/with_user/:user_id'
</ruby>

This route would respond to paths such as +/photos/show/1/with_user/2+. In this case, +params+ would be <tt>{ :controller => "photos", :action => "show", :id => "1", :user_id => "2" }</tt>.

h4. The Query String

The +params+ will also include any parameters from the query string. For example, with this route:

<ruby>
match ':controller/:action/:id'
</ruby>

An incoming path of +/photos/show/1?user_id=2+ will be dispatched to the +show+ action of the +Photos+ controller. +params+ will be <tt>{ :controller => "photos", :action => "show", :id => "1", :user_id => "2" }</tt>.

h4. Defining Defaults

You do not need to explicitly use the +:controller+ and +:action+ symbols within a route. You can supply them as defaults:

<ruby>
match 'photos/:id' => 'photos#show'
</ruby>

With this route, Rails will match an incoming path of +/photos/12+ to the +show+ action of +PhotosController+.

You can also define other defaults in a route by supplying a hash for the +:defaults+ option. This even applies to parameters that you do not specify as dynamic segments. For example:

<ruby>
match 'photos/:id' => 'photos#show', :defaults => { :format => 'jpg' }
</ruby>

Rails would match +photos/12+ to the +show+ action of +PhotosController+, and set +params[:format]+ to +"jpg"+.

h4. Naming Routes

You can specify a name for any route using the +:as+ option.

<ruby>
match 'exit' => 'sessions#destroy', :as => :logout
</ruby>

This will create +logout_path+ and +logout_url+ as named helpers in your application. Calling +logout_path+ will return +/exit+

h4. HTTP Verb Constraints

You can use the +:via+ option to constrain the request to one or more HTTP methods:

<ruby>
match 'photos/show' => 'photos#show', :via => :get
</ruby>

There is a shorthand version of this as well:

<ruby>
get 'photos/show'
</ruby>

You can also permit more than one verb to a single route:

<ruby>
match 'photos/show' => 'photos#show', :via => [:get, :post]
</ruby>

h4. Segment Constraints

You can use the +:constraints+ option to enforce a format for a dynamic segment:

<ruby>
match 'photos/:id' => 'photos#show', :constraints => { :id => /[A-Z]\d{5}/ }
</ruby>

This route would match paths such as +/photos/A12345+. You can more succinctly express the same route this way:

<ruby>
match 'photos/:id' => 'photos#show', :id => /[A-Z]\d{5}/
</ruby>

+:constraints+ takes regular expressions with the restriction that regexp anchors can't be used. For example, the following route will not work:

<ruby>
match '/:id' => 'posts#show', :constraints => {:id => /^\d/}
</ruby>

However, note that you don't need to use anchors because all routes are anchored at the start.

For example, the following routes would allow for +posts+ with +to_param+ values like +1-hello-world+ that always begin with a number and +users+ with +to_param+ values like +david+ that never begin with a number to share the root namespace:

<ruby>
match '/:id' => 'posts#show', :constraints => { :id => /\d.+/ }
match '/:username' => 'users#show'
</ruby>

h4. Request-Based Constraints

You can also constrain a route based on any method on the <a href="action_controller_overview.html#the-request-object">Request</a> object that returns a +String+.

You specify a request-based constraint the same way that you specify a segment constraint:

<ruby>
match "photos", :constraints => {:subdomain => "admin"}
</ruby>

You can also specify constraints in a block form:

<ruby>
namespace :admin do
  constraints :subdomain => "admin" do
    resources :photos
  end
end
</ruby>

h4. Advanced Constraints

If you have a more advanced constraint, you can provide an object that responds to +matches?+ that Rails should use. Let's say you wanted to route all users on a blacklist to the +BlacklistController+. You could do:

<ruby>
class BlacklistConstraint
  def initialize
    @ips = Blacklist.retrieve_ips
  end

  def matches?(request)
    @ips.include?(request.remote_ip)
  end
end

TwitterClone::Application.routes.draw do
  match "*path" => "blacklist#index",
    :constraints => BlacklistConstraint.new
end
</ruby>

h4. Route Globbing

Route globbing is a way to specify that a particular parameter should be matched to all the remaining parts of a route. For example

<ruby>
match 'photos/*other' => 'photos#unknown'
</ruby>

This route would match +photos/12+ or +/photos/long/path/to/12+, setting +params[:other]+ to +"12"+ or +"long/path/to/12"+.

Wildcard segments can occur anywhere in a route. For example,

<ruby>
match 'books/*section/:title' => 'books#show'
</ruby>

would match +books/some/section/last-words-a-memoir+ with +params[:section]+ equals +"some/section"+, and +params[:title]+ equals +"last-words-a-memoir"+.

Technically a route can have even more than one wildcard segment. The matcher assigns segments to parameters in an intuitive way. For example,

<ruby>
match '*a/foo/*b' => 'test#index'
</ruby>

would match +zoo/woo/foo/bar/baz+ with +params[:a]+ equals +"zoo/woo"+, and +params[:b]+ equals +"bar/baz"+.

NOTE: Starting from Rails 3.1, wildcard routes will always match the optional format segment by default. For example if you have this route:

<ruby>
match '*pages' => 'pages#show'
</ruby>

NOTE: By requesting +"/foo/bar.json"+, your +params[:pages]+ will be equals to +"foo/bar"+ with the request format of JSON. If you want the old 3.0.x behavior back, you could supply +:format => false+ like this:

<ruby>
match '*pages' => 'pages#show', :format => false
</ruby>

NOTE: If you want to make the format segment mandatory, so it cannot be omitted, you can supply +:format => true+ like this:

<ruby>
match '*pages' => 'pages#show', :format => true
</ruby>

h4. Redirection

You can redirect any path to another path using the +redirect+ helper in your router:

<ruby>
match "/stories" => redirect("/posts")
</ruby>

You can also reuse dynamic segments from the match in the path to redirect to:

<ruby>
match "/stories/:name" => redirect("/posts/%{name}")
</ruby>

You can also provide a block to redirect, which receives the params and (optionally) the request object:

<ruby>
match "/stories/:name" => redirect {|params| "/posts/#{params[:name].pluralize}" }
match "/stories" => redirect {|p, req| "/posts/#{req.subdomain}" }
</ruby>

Please note that this redirection is a 301 "Moved Permanently" redirect. Keep in mind that some web browsers or proxy servers will cache this type of redirect, making the old page inaccessible.

In all of these cases, if you don't provide the leading host (+http://www.example.com+), Rails will take those details from the current request.

h4. Routing to Rack Applications

Instead of a String, like +"posts#index"+, which corresponds to the +index+ action in the +PostsController+, you can specify any <a href="rails_on_rack.html">Rack application</a> as the endpoint for a matcher.

<ruby>
match "/application.js" => Sprockets
</ruby>

As long as +Sprockets+ responds to +call+ and returns a <tt>[status, headers, body]</tt>, the router won't know the difference between the Rack application and an action.

NOTE: For the curious, +"posts#index"+ actually expands out to +PostsController.action(:index)+, which returns a valid Rack application.

h4. Using +root+

You can specify what Rails should route +"/"+ to with the +root+ method:

<ruby>
root :to => 'pages#main'
root 'pages#main' # shortcut for the above
</ruby>

You should put the +root+ route at the top of the file, because it is the most popular route and should be matched first. You also need to delete the +public/index.html+ file for the root route to take effect.

h3. Customizing Resourceful Routes

While the default routes and helpers generated by +resources :posts+ will usually serve you well, you may want to customize them in some way. Rails allows you to customize virtually any generic part of the resourceful helpers.

h4. Specifying a Controller to Use

The +:controller+ option lets you explicitly specify a controller to use for the resource. For example:

<ruby>
resources :photos, :controller => "images"
</ruby>

will recognize incoming paths beginning with +/photos+ but route to the +Images+ controller:

|_.HTTP Verb |_.Path           |_.action |_.named helper        |
|GET         |/photos          |index    | photos_path          |
|GET         |/photos/new      |new      | new_photo_path       |
|POST        |/photos          |create   | photos_path          |
|GET         |/photos/:id      |show     | photo_path(:id)      |
|GET         |/photos/:id/edit |edit     | edit_photo_path(:id) |
|PATCH/PUT   |/photos/:id      |update   | photo_path(:id)      |
|DELETE      |/photos/:id      |destroy  | photo_path(:id)      |

NOTE: Use +photos_path+, +new_photo_path+, etc. to generate paths for this resource.

h4. Specifying Constraints

You can use the +:constraints+ option to specify a required format on the implicit +id+. For example:

<ruby>
resources :photos, :constraints => {:id => /[A-Z][A-Z][0-9]+/}
</ruby>

This declaration constrains the +:id+ parameter to match the supplied regular expression. So, in this case, the router would no longer match +/photos/1+ to this route. Instead, +/photos/RR27+ would match.

You can specify a single constraint to apply to a number of routes by using the block form:

<ruby>
constraints(:id => /[A-Z][A-Z][0-9]+/) do
  resources :photos
  resources :accounts
end
</ruby>

NOTE: Of course, you can use the more advanced constraints available in non-resourceful routes in this context.

TIP: By default the +:id+ parameter doesn't accept dots - this is because the dot is used as a separator for formatted routes. If you need to use a dot within an +:id+ add a constraint which overrides this - for example +:id+ => /[^\/]+/ allows anything except a slash.

h4. Overriding the Named Helpers

The +:as+ option lets you override the normal naming for the named route helpers. For example:

<ruby>
resources :photos, :as => "images"
</ruby>

will recognize incoming paths beginning with +/photos+ and route the requests to +PhotosController+, but use the value of the :as option to name the helpers.

|_.HTTP verb|_.Path            |_.action |_.named helper        |
|GET        |/photos           |index    | images_path          |
|GET        |/photos/new       |new      | new_image_path       |
|POST       |/photos           |create   | images_path          |
|GET        |/photos/:id       |show     | image_path(:id)      |
|GET        |/photos/:id/edit  |edit     | edit_image_path(:id) |
|PATCH/PUT  |/photos/:id       |update   | image_path(:id)      |
|DELETE     |/photos/:id       |destroy  | image_path(:id)      |

h4. Overriding the +new+ and +edit+ Segments

The +:path_names+ option lets you override the automatically-generated "new" and "edit" segments in paths:

<ruby>
resources :photos, :path_names => { :new => 'make', :edit => 'change' }
</ruby>

This would cause the routing to recognize paths such as

<plain>
/photos/make
/photos/1/change
</plain>

NOTE: The actual action names aren't changed by this option. The two paths shown would still route to the +new+ and +edit+ actions.

TIP: If you find yourself wanting to change this option uniformly for all of your routes, you can use a scope.

<ruby>
scope :path_names => { :new => "make" } do
  # rest of your routes
end
</ruby>

h4. Prefixing the Named Route Helpers

You can use the +:as+ option to prefix the named route helpers that Rails generates for a route. Use this option to prevent name collisions between routes using a path scope.

<ruby>
scope "admin" do
  resources :photos, :as => "admin_photos"
end

resources :photos
</ruby>

This will provide route helpers such as +admin_photos_path+, +new_admin_photo_path+ etc.

To prefix a group of route helpers, use +:as+ with +scope+:

<ruby>
scope "admin", :as => "admin" do
  resources :photos, :accounts
end

resources :photos, :accounts
</ruby>

This will generate routes such as +admin_photos_path+ and +admin_accounts_path+ which map to +/admin/photos+ and +/admin/accounts+ respectively.

NOTE: The +namespace+ scope will automatically add +:as+ as well as +:module+ and +:path+ prefixes.

You can prefix routes with a named parameter also:

<ruby>
scope ":username" do
  resources :posts
end
</ruby>

This will provide you with URLs such as +/bob/posts/1+ and will allow you to reference the +username+ part of the path as +params[:username]+ in controllers, helpers and views.

h4. Restricting the Routes Created

By default, Rails creates routes for the seven default actions (index, show, new, create, edit, update, and destroy) for every RESTful route in your application. You can use the +:only+ and +:except+ options to fine-tune this behavior. The +:only+ option tells Rails to create only the specified routes:

<ruby>
resources :photos, :only => [:index, :show]
</ruby>

Now, a +GET+ request to +/photos+ would succeed, but a +POST+ request to +/photos+ (which would ordinarily be routed to the +create+ action) will fail.

The +:except+ option specifies a route or list of routes that Rails should _not_ create:

<ruby>
resources :photos, :except => :destroy
</ruby>

In this case, Rails will create all of the normal routes except the route for +destroy+ (a +DELETE+ request to +/photos/:id+).

TIP: If your application has many RESTful routes, using +:only+ and +:except+ to generate only the routes that you actually need can cut down on memory use and speed up the routing process.

h4. Translated Paths

Using +scope+, we can alter path names generated by resources:

<ruby>
scope(:path_names => { :new => "neu", :edit => "bearbeiten" }) do
  resources :categories, :path => "kategorien"
end
</ruby>

Rails now creates routes to the +CategoriesController+.

|_.HTTP verb|_.Path                     |_.action |_.named helper           |
|GET        |/kategorien                |index    | categories_path         |
|GET        |/kategorien/neu            |new      | new_category_path       |
|POST       |/kategorien                |create   | categories_path         |
|GET        |/kategorien/:id            |show     | category_path(:id)      |
|GET        |/kategorien/:id/bearbeiten |edit     | edit_category_path(:id) |
|PATCH/PUT  |/kategorien/:id            |update   | category_path(:id)      |
|DELETE     |/kategorien/:id            |destroy  | category_path(:id)      |

h4. Overriding the Singular Form

If you want to define the singular form of a resource, you should add additional rules to the +Inflector+.

<ruby>
ActiveSupport::Inflector.inflections do |inflect|
  inflect.irregular 'tooth', 'teeth'
end
</ruby>

h4(#nested-names). Using +:as+ in Nested Resources

The +:as+ option overrides the automatically-generated name for the resource in nested route helpers. For example,

<ruby>
resources :magazines do
  resources :ads, :as => 'periodical_ads'
end
</ruby>

This will create routing helpers such as +magazine_periodical_ads_url+ and +edit_magazine_periodical_ad_path+.

h3. Inspecting and Testing Routes

Rails offers facilities for inspecting and testing your routes.

h4. Seeing Existing Routes with +rake+

If you want a complete list of all of the available routes in your application, run +rake routes+ command. This will print all of your routes, in the same order that they appear in +routes.rb+. For each route, you'll see:

* The route name (if any)
* The HTTP verb used (if the route doesn't respond to all verbs)
* The URL pattern to match
* The routing parameters for the route

For example, here's a small section of the +rake routes+ output for a RESTful route:

<pre>
    users GET    /users(.:format)          users#index
          POST   /users(.:format)          users#create
 new_user GET    /users/new(.:format)      users#new
edit_user GET    /users/:id/edit(.:format) users#edit
</pre>

You may restrict the listing to the routes that map to a particular controller setting the +CONTROLLER+ environment variable:

<shell>
$ CONTROLLER=users rake routes
</shell>

TIP: You'll find that the output from +rake routes+ is much more readable if you widen your terminal window until the output lines don't wrap.

h4. Testing Routes

Routes should be included in your testing strategy (just like the rest of your application). Rails offers three "built-in assertions":http://api.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html designed to make testing routes simpler:

* +assert_generates+
* +assert_recognizes+
* +assert_routing+

h5. The +assert_generates+ Assertion

+assert_generates+ asserts that a particular set of options generate a particular path and can be used with default routes or custom routes.

<ruby>
assert_generates "/photos/1", { :controller => "photos", :action => "show", :id => "1" }
assert_generates "/about", :controller => "pages", :action => "about"
</ruby>

h5. The +assert_recognizes+ Assertion

+assert_recognizes+ is the inverse of +assert_generates+. It asserts that a given path is recognized and routes it to a particular spot in your application.

<ruby>
assert_recognizes({ :controller => "photos", :action => "show", :id => "1" }, "/photos/1")
</ruby>

You can supply a +:method+ argument to specify the HTTP verb:

<ruby>
assert_recognizes({ :controller => "photos", :action => "create" }, { :path => "photos", :method => :post })
</ruby>

h5. The +assert_routing+ Assertion

The +assert_routing+ assertion checks the route both ways: it tests that the path generates the options, and that the options generate the path. Thus, it combines the functions of +assert_generates+ and +assert_recognizes+.

<ruby>
assert_routing({ :path => "photos", :method => :post }, { :controller => "photos", :action => "create" })
</ruby>
